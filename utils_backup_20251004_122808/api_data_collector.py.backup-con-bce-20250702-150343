"""
Módulo para recopilar datos macroeconómicos y sectoriales de fuentes oficiales españolas
"""

import requests
import pandas as pd
from datetime import datetime
from typing import Dict, List, Optional, Tuple
import json
import time

class APIDataCollector:
    """
    Recopila datos económicos de fuentes oficiales españolas
    """
    
    def __init__(self):
        """Inicializa el recopilador con las URLs base de las APIs"""
        
        # APIs del Banco de España
        self.bde_base_url = "https://www.bde.es/webbe/es/estadisticas/compartido/datos/"
        
        # API del INE (Instituto Nacional de Estadística)
        self.ine_base_url = "https://servicios.ine.es/wstempus/js/ES/"
        
        # Timeout para las peticiones
        self.timeout = 30
        
        # Headers para las peticiones
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (compatible; BusinessPlanIA/1.0)',
            'Accept': 'application/json'
        }
        
    def get_datos_macroeconomicos(self) -> Dict[str, float]:
        """
        Obtiene datos macroeconómicos actualizados
        
        Returns:
            Dict con PIB, inflación, euribor, desempleo
        """
        datos_macro = {
            'pib': 2.5,  # Valor por defecto
            'inflacion': 3.0,
            'euribor': 4.0,
            'desempleo': 12.0,
            'fecha_actualizacion': datetime.now().strftime('%Y-%m-%d')
        }
        
        try:
            # Obtener PIB del INE
            pib = self._get_pib_ine()
            if pib is not None:
                datos_macro['pib'] = pib
                
            # Obtener inflación del INE
            inflacion = self._get_inflacion_ine()
            if inflacion is not None:
                datos_macro['inflacion'] = inflacion
                
            # Obtener Euribor
            euribor = self._get_euribor()
            if euribor is not None:
                datos_macro['euribor'] = euribor
                
            # Obtener desempleo del INE
            desempleo = self._get_desempleo_ine()
            if desempleo is not None:
                datos_macro['desempleo'] = desempleo
                
        except Exception as e:
            print(f"Error al obtener datos macroeconómicos: {e}")
            
        return datos_macro
    
    def _get_pib_ine(self) -> Optional[float]:
        """Obtiene el crecimiento del PIB del INE"""
        try:
            # Código de la serie del PIB trimestral
            url = f"{self.ine_base_url}DATOS_SERIE/CNTR4837?nult=10"
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                # Procesar datos reales del INE
                if "Data" in data and len(data["Data"]) > 0:
                    ultimo_valor = data["Data"][-1]["Valor"]
                    return float(ultimo_valor)            
        except Exception as e:
            print(f"Error obteniendo PIB: {e}")
            
        return None


    def _get_desempleo_ine(self) -> Optional[float]:
        """Obtiene la tasa de desempleo"""
        # Por ahora retornamos el valor actual aproximado
        # TODO: Implementar con API real cuando encontremos una que funcione
        return 11.2  # Tasa de paro actual España Q3 2024


    def _get_inflacion_ine(self) -> Optional[float]:
        """Obtiene la tasa de inflación del INE"""
        try:
            # Serie del INE para inflación - IPC variación anual
            url = f"{self.ine_base_url}DATOS_SERIE/IPC251856?nult=5"
            
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                # Procesar datos reales del INE
                if "Data" in data and len(data["Data"]) > 0:
                    ultimo_valor = data["Data"][-1]["Valor"]
                    return float(ultimo_valor)
        except Exception as e:
            print(f"Error obteniendo inflación: {e}")
            
        return None

    def _get_euribor(self) -> Optional[float]:
        """Obtiene el Euribor a 12 meses del BCE"""
        try:
            # API oficial del BCE - Statistical Data Warehouse
            url = "https://sdw-wsrest.ecb.europa.eu/service/data/FM/D.U2.EUR.4F.KR.MLFR.LEV?lastNObservations=1"
            headers = {"Accept": "application/json"}
            
            response = requests.get(url, headers=headers, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                if "dataSets" in data and len(data["dataSets"]) > 0:
                    dataset = data["dataSets"][0]
                    if "series" in dataset:
                        for key, serie in dataset["series"].items():
                            if "observations" in serie:
                                obs = serie["observations"]
                                for obs_key, values in obs.items():
                                    return float(values[0])
                                    
        except Exception as e:
            print(f"Error obteniendo Euribor del BCE: {e}")
            
        return None

    def get_datos_sectoriales(self, sector: str) -> Dict[str, any]:
        """
        Obtiene datos sectoriales
        Por ahora retorna estructura básica hasta tener APIs funcionales
        """
        # Obtener PIB real
        pib_actual = self._get_pib_ine()
        
        # Estructura requerida por la app
        datos_sector = {
            "crecimiento_sectorial": pib_actual if pib_actual else 5.0,
            "multiples_valoracion": {},
            "tendencias": [],
            "fecha_actualizacion": datetime.now().strftime("%Y-%m-%d")
        }
        
        # TODO: Implementar cuando tengamos acceso a APIs sectoriales reales:
        # - Banco de España: Series sectoriales
        # - Eurostat: Datos por NACE
        # - Observatorios sectoriales públicos
        
        
        # Agregar información de fuentes bancarias disponibles
        datos_bancarios = self.get_datos_bancarios_publicos(sector)
        if datos_bancarios["fuentes_disponibles"]:
            datos_sector["fuentes_bancarias"] = datos_bancarios["fuentes_disponibles"]
            datos_sector["nota_bancaria"] = "Datos bancarios disponibles para análisis más profundo"
        return datos_sector

    def get_datos_funcas(self, sector: str) -> Dict[str, any]:
        """
        Obtiene datos de FUNCAS - Panel de previsiones económicas
        """
        try:
            # FUNCAS publica sus previsiones en formato JSON
            # Panel de previsiones de la economía española
            url = "https://www.funcas.es/wp-json/funcas/v1/indicadores/prevision-crecimiento"
            
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                
                # Extraer previsiones sectoriales si están disponibles
                previsiones = {
                    "pib_prevision": None,
                    "consumo_prevision": None,
                    "inversion_prevision": None,
                    "fuente": "FUNCAS - Panel de previsiones",
                    "fecha": datetime.now().strftime("%Y-%m-%d")
                }
                
                # Procesar datos según estructura de FUNCAS
                if "previsiones" in data:
                    previsiones["pib_prevision"] = data["previsiones"].get("pib", {}).get("2025", None)
                    previsiones["consumo_prevision"] = data["previsiones"].get("consumo", {}).get("2025", None)
                    
                return previsiones
                
        except Exception as e:
            print(f"Error obteniendo datos FUNCAS: {e}")
            
        return None

    def get_datos_bce(self) -> Dict[str, any]:
        """
        Obtiene datos del Banco Central Europeo
        """
        try:
            url = "https://api.frankfurter.app/latest?from=EUR"
            response = requests.get(url, headers=self.headers, timeout=self.timeout)
            
            if response.status_code == 200:
                data = response.json()
                datos_bce = {
                    "tipo_cambio_usd": data.get("rates", {}).get("USD", None),
                    "tipo_cambio_gbp": data.get("rates", {}).get("GBP", None),
                    "fecha": data.get("date", ""),
                    "fuente": "Banco Central Europeo"
                }
                return datos_bce
                
        except Exception as e:
            print(f"Error obteniendo datos BCE: {e}")
            
        return None
    def get_datos_bancarios_publicos(self, sector: str) -> Dict[str, any]:
        """
        Obtiene datos de investigación bancaria de fuentes públicas
        """
        datos_bancarios = {
            "fuentes": [],
            "analisis_disponible": False
        }
        
        sector_norm = sector.lower().replace("í", "i").replace("ó", "o")
        
        # Marcar qué fuentes públicas están disponibles
        fuentes_disponibles = {
            "funcas": "https://www.funcas.es/indicadores/",
            "bde": "https://www.bde.es/bde/es/areas/cenbal/",
            "bbva_research": "https://www.bbvaresearch.com/publicaciones/",
            "caixabank_research": "https://www.caixabankresearch.com/es/publicaciones"
        }
        
        datos_bancarios["fuentes_disponibles"] = fuentes_disponibles
        datos_bancarios["nota"] = "Implementar cuando se obtengan API keys"
        
        return datos_bancarios
