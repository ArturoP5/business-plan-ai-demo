# models/modelo_financiero.py

from datetime import datetime
from typing import Dict, List, Optional, Tuple
import pandas as pd
import numpy as np
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
# from valoracion_profesional import ValoracionProfesional
from utils.valoracion_bancainversion import realizar_valoracion_profesional
from utils.api_data_collector import APIDataCollector
from models.balance_parameters import (
    POLITICA_DIVIDENDOS, LIMITES_DEUDA_SECTOR, WACC_OBJETIVO_SECTOR, 
    determinar_fase_empresa, INVERSION_INTANGIBLES_SECTOR, 
    AMORTIZACION_INTANGIBLES_ANUAL, INVERSIONES_CP_PCT_TESORERIA, 
    GASTOS_ANTICIPADOS_PCT_GASTOS, TESORERIA_OBJETIVO_MULTIPLE,
    calcular_inversion_lp_adicional
)
class ModeloFinanciero:
    """
    Modelo financiero completo para PYMEs
    Genera P&L, Balance y Cash Flow proyectados
    """
    def __init__(self, empresa_info: dict, escenario_macro: dict, params_operativos: dict):
        """
        Inicializa el modelo financiero con estructura completa
        """
        # Inicializar el recopilador de datos de APIs
        self.api_collector = APIDataCollector()
        
        # Obtener datos actualizados si est√° disponible
        try:
            datos_actualizados = self.api_collector.get_datos_macroeconomicos()
            # Actualizar valores macro con datos reales si est√°n disponibles
            escenario_macro['pib'] = datos_actualizados.get('pib', escenario_macro.get('pib', 1.9))
            escenario_macro['inflacion'] = datos_actualizados.get('inflacion', escenario_macro.get('inflacion', 2.5))
            escenario_macro['euribor'] = datos_actualizados.get('euribor', escenario_macro.get('euribor', 2.7))
            escenario_macro['desempleo'] = datos_actualizados.get('desempleo', escenario_macro.get('desempleo', 11.7))
            print(f"‚úì Datos macroecon√≥micos actualizados: {datos_actualizados['fecha_actualizacion']}")
        except Exception as e:
            print(f"‚ö†Ô∏è Usando valores por defecto para datos macro: {e}")
            
        # Informaci√≥n b√°sica de la empresa
        self.nombre = empresa_info.get('nombre', 'Empresa')
        self.sector = empresa_info.get('sector', 'servicios')
        self.empresa_familiar = empresa_info.get('empresa_familiar', 'No')
        self.empresa_auditada = empresa_info.get('empresa_auditada', 'S√≠')
        self.a√±o_fundacion = empresa_info.get('a√±o_fundacion', datetime.now().year)

        
        # Par√°metros de balance (McKinsey)
        # Determinar fase de la empresa
        a√±os_operacion = datetime.now().year - self.a√±o_fundacion
        crecimiento_historico = params_operativos.get('crecimiento_historico', 10)
        self.fase_empresa = determinar_fase_empresa(a√±os_operacion, crecimiento_historico)
        
        # Obtener par√°metros por defecto seg√∫n sector y fase
        self.limite_deuda_ebitda = params_operativos.get(
            'limite_deuda_ebitda', 
            LIMITES_DEUDA_SECTOR.get(self.sector, 2.5)
        )
        self.payout_ratio = params_operativos.get(
            'payout_ratio',
            POLITICA_DIVIDENDOS.get(self.fase_empresa, 0.25)
        )
        self.wacc_objetivo = params_operativos.get(
            'wacc_objetivo',
            WACC_OBJETIVO_SECTOR.get(self.sector, 10.0)
        )
        self.empleados = empresa_info.get('empleados', 10)
        
        # Escenario macroecon√≥mico
        self.pib_crecimiento = escenario_macro.get('pib', 1.9)
        self.inflacion = escenario_macro.get('inflacion', 2.5)
        self.euribor = escenario_macro.get('euribor', 2.7)
        self.tasa_desempleo = escenario_macro.get('desempleo', 11.7)
        
        # Par√°metros operativos
        self.ingresos_iniciales = params_operativos.get('ingresos_iniciales', 10_000_000)
        self.crecimiento_ventas = params_operativos.get('crecimiento_ventas', 5.0)
        self.margen_ebitda_inicial = params_operativos.get('margen_ebitda', 12.0)
        self.crecimiento_por_a√±o = params_operativos.get("crecimiento_por_a√±o", [self.crecimiento_ventas] * 5)
        self.ebitda_real = params_operativos.get('ebitda_real', None)
        self.margen_ebitda_real = params_operativos.get('margen_ebitda_real', None)
        self.capex_porcentaje = params_operativos.get('capex_ventas', 3.0)
        self.dias_cobro = params_operativos.get('dias_cobro', 60)
        self.dias_pago = params_operativos.get('dias_pago', 45)
        self.dias_inventario = params_operativos.get('dias_inventario', 30)

        self.tipo_escenario = params_operativos.get("tipo_escenario", "Base")
        # Estructura de costos
        self.costos_variables_pct = params_operativos.get('costos_variables_pct', 0.6)
        self.gastos_personal = params_operativos.get('gastos_personal', 0)
        self.gastos_generales = params_operativos.get('gastos_generales', 0)
        self.gastos_marketing = params_operativos.get('gastos_marketing', 0)
        self.gastos_personal_historico = params_operativos.get('gastos_personal_historico', None)
        self.gastos_generales_historico = params_operativos.get('gastos_generales_historico', None)
        self.gastos_marketing_historico = params_operativos.get('gastos_marketing_historico', None)
        
        # Gastos proyectados (arrays de 5 a√±os definidos por usuario)
        self.gastos_personal_proyectados = params_operativos.get('gastos_personal_proyectados', None)
        self.gastos_generales_proyectados = params_operativos.get('gastos_generales_proyectados', None)
        self.gastos_marketing_proyectados = params_operativos.get('gastos_marketing_proyectados', None)
        self.ventas_historicas = params_operativos.get('ventas_historicas', [self.ingresos_iniciales])
        print(f"üîç Gastos proyectados recibidos: Personal={self.gastos_personal_proyectados}, Generales={self.gastos_generales_proyectados}, Marketing={self.gastos_marketing_proyectados}")
        self.otros_gastos = params_operativos.get('otros_gastos', 0)
                
        # NUEVA ESTRUCTURA FINANCIERA COMPLETA
        # Balance inicial
        self.activo_fijo_inicial = params_operativos.get('activo_fijo', 5_000_000)
        self.inventario_inicial = params_operativos.get('inventario', 1_000_000)
        self.clientes_inicial = params_operativos.get('clientes', 2_000_000)
        self.proveedores_inicial = params_operativos.get('proveedores', 1_500_000)
        self.pasivo_laboral = params_operativos.get('pasivo_laboral', 0)
        self.provisiones_laborales = params_operativos.get('provisiones_laborales', 0)
        self.inversiones_cp_inicial = params_operativos.get('inversiones_cp', 0)
        self.gastos_anticipados_inicial = params_operativos.get('gastos_anticipados', 0)
        self.otros_activos_corrientes_inicial = params_operativos.get('otros_activos_corrientes', 0)
        
        # Activos no corrientes
        self.activo_fijo_bruto_inicial = params_operativos.get('activo_fijo_bruto', 5_000_000)
        self.depreciacion_acumulada_inicial = params_operativos.get('depreciacion_acumulada', 1_000_000)
        self.activo_fijo_neto_inicial = params_operativos.get('activo_fijo_neto', self.activo_fijo_bruto_inicial - self.depreciacion_acumulada_inicial)
        self.activos_intangibles_inicial = params_operativos.get('activos_intangibles', 0)
        self.inversiones_lp_inicial = params_operativos.get('inversiones_lp', 0)
        self.otros_activos_nc_inicial = params_operativos.get('otros_activos_nc', 0)
        # Recalcular activo fijo neto con los valores correctos
        self.activo_fijo_inicial = self.activo_fijo_bruto_inicial - self.depreciacion_acumulada_inicial
        self.activos_intangibles_inicial = params_operativos.get('activos_intangibles', 0)
        self.inversiones_lp_inicial = params_operativos.get('inversiones_lp', 0)
        self.otros_activos_nc_inicial = params_operativos.get('otros_activos_nc', 0)
        
        # Patrimonio
        self.resultados_acumulados = params_operativos.get('resultados_acumulados', 0)
        self.tesoreria_inicial = params_operativos.get('tesoreria', 500_000)
        
        # Estructura de capital
        self.capital_social = params_operativos.get('capital_social', 3_000_000)
        self.reservas = params_operativos.get('reservas', 1_000_000)
        self.reserva_legal = params_operativos.get('reserva_legal', 0)
        
        # Financiaci√≥n bancaria detallada
        self.prestamos_lp = params_operativos.get('prestamos_lp', [])
        self.hipotecas = params_operativos.get('hipotecas', [])
        self.leasings = params_operativos.get('leasings', [])
        self.polizas_credito = params_operativos.get('polizas_credito', [])
        # DEBUG: Ver qu√© datos llegan
        print(f"DEBUG - Hipotecas: {self.hipotecas}")
        print(f"DEBUG - Leasings: {self.leasings}")
        print(f"DEBUG - P√≥lizas: {self.polizas_credito}")
        self.factoring = params_operativos.get('factoring', {})
        self.confirming = params_operativos.get('confirming', {})
        
        # Plan de inversiones CAPEX
        self.plan_capex = params_operativos.get('plan_capex', [])
        
        # Otros par√°metros financieros
        self.tasa_impuestos = params_operativos.get('tasa_impuestos', 25.0)
        self.dividendos_payout = params_operativos.get('dividendos_payout', 30.0)
        self.rating_crediticio = params_operativos.get('rating', 'BB')
        
        # Sistema de valoraci√≥n profesional
#         self.valorador = ValoracionProfesional()
        
        # DataFrames para almacenar proyecciones
        self.pyl = None
        self.balance = None
        self.cash_flow = None
        self.ratios = None

        # Actualizar con datos sectoriales si est√°n disponibles
        self.actualizar_datos_sectoriales()


    def calcular_ebitda_historico(self, a√±o_idx: int) -> float:
        """Calcula el EBITDA hist√≥rico para un a√±o espec√≠fico"""
        if a√±o_idx < 0 or a√±o_idx >= len(self.ventas_historicas):
            return 0
        
        ventas = self.ventas_historicas[a√±o_idx]
        costos = ventas * self.costos_variables_pct
        
        # Usar gastos proyectados si est√°n disponibles, sino hist√≥ricos, sino crecimiento inteligente
        if self.gastos_personal_proyectados and a√±o_idx < len(self.gastos_personal_proyectados) and any(x > 0 for x in self.gastos_personal_proyectados):
            gastos_personal = self.gastos_personal_proyectados[a√±o_idx]
        elif self.gastos_personal_historico and a√±o_idx < len(self.gastos_personal_historico):
            gastos_personal = self.gastos_personal_historico[a√±o_idx]
        else:
            # Crecimiento inteligente basado en ventas
            if a√±o_idx > 0:
                crecimiento_ventas = (self.ventas_historicas[a√±o_idx] - self.ventas_historicas[a√±o_idx-1]) / self.ventas_historicas[a√±o_idx-1]
                # Personal crece en escalones
                if crecimiento_ventas < 0.10:
                    factor_personal = 1 + (crecimiento_ventas * 0.5)
                else:
                    factor_personal = 1 + (crecimiento_ventas * 0.7)
                # L√≠mites razonables
                factor_personal = max(0.90, min(factor_personal, 1.50))
                gastos_personal = self.gastos_personal * factor_personal
            else:
                gastos_personal = self.gastos_personal
            
        if self.gastos_generales_proyectados and a√±o_idx < len(self.gastos_generales_proyectados) and any(x > 0 for x in self.gastos_generales_proyectados):
            gastos_generales = self.gastos_generales_proyectados[a√±o_idx]
        elif self.gastos_generales_historico and a√±o_idx < len(self.gastos_generales_historico):
            gastos_generales = self.gastos_generales_historico[a√±o_idx]
        else:
            # Econom√≠as de escala
            if a√±o_idx > 0:
                crecimiento_ventas = (self.ventas_historicas[a√±o_idx] - self.ventas_historicas[a√±o_idx-1]) / self.ventas_historicas[a√±o_idx-1]
                factor_generales = 1 + (crecimiento_ventas * 0.40)
                factor_generales = max(0.90, min(factor_generales, 1.50))
                gastos_generales = self.gastos_generales * factor_generales
            else:
                gastos_generales = self.gastos_generales
            
        if self.gastos_marketing_proyectados and a√±o_idx < len(self.gastos_marketing_proyectados) and any(x > 0 for x in self.gastos_marketing_proyectados):
            gastos_marketing = self.gastos_marketing_proyectados[a√±o_idx]
        elif self.gastos_marketing_historico and a√±o_idx < len(self.gastos_marketing_historico):
            gastos_marketing = self.gastos_marketing_historico[a√±o_idx]
        else:
            # Marketing correlacionado con crecimiento
            if a√±o_idx > 0:
                crecimiento_ventas = (self.ventas_historicas[a√±o_idx] - self.ventas_historicas[a√±o_idx-1]) / self.ventas_historicas[a√±o_idx-1]
                factor_marketing = 1 + (crecimiento_ventas * 0.80)
                factor_marketing = max(0.90, min(factor_marketing, 1.50))
                gastos_marketing = self.gastos_marketing * factor_marketing
            else:
                gastos_marketing = self.gastos_marketing
        return ventas - costos - gastos_personal - gastos_generales - gastos_marketing

    def actualizar_datos_sectoriales(self):
        """
        Actualiza los par√°metros del modelo con datos sectoriales de APIs
        """
        try:
            # Obtener datos del sector
            datos_sector = self.api_collector.get_datos_sectoriales(self.sector)
            
            # Obtener m√∫ltiplos de valoraci√≥n
            multiples = self.api_collector.get_datos_cnmv(self.sector)
            
            # Actualizar par√°metros si hay datos disponibles
            if datos_sector:
                # Ajustar crecimiento seg√∫n sector
                crecimiento_sector = datos_sector.get('crecimiento_sectorial', 5.0)
                self.crecimiento_ventas = (self.crecimiento_ventas + crecimiento_sector) / 2
                
                
                # Ajustar margen EBITDA seg√∫n sector
                margen_sector = datos_sector.get('margen_ebitda_medio', 15.0)
                self.margen_ebitda_inicial = (self.margen_ebitda_inicial + margen_sector) / 2
                
                print(f"‚úì Datos sectoriales actualizados para {self.sector}")
                print(f"  - Crecimiento ajustado: {self.crecimiento_ventas:.1f}%")
                print(f"  - Margen EBITDA ajustado: {self.margen_ebitda_inicial:.1f}%")
                
            # Guardar m√∫ltiplos para valoraci√≥n
            self.multiples_sector = multiples
            
        except Exception as e:
            print(f"‚ö†Ô∏è No se pudieron actualizar datos sectoriales: {e}")

    def calcular_deuda_total(self, a√±o_actual: int = 1, incluir_pasivo_laboral: bool = True) -> float:
        """
        Calcula la deuda total pendiente actual de todas las fuentes
        
        Args:
            a√±o_actual: A√±o para el c√°lculo
            incluir_pasivo_laboral: Si incluir el pasivo laboral en la deuda total
        """
        deuda = 0
        
        # Incluir pasivo laboral si corresponde
        if incluir_pasivo_laboral:
            deuda += self.pasivo_laboral
        
        # Pr√©stamos largo plazo - calcular saldo pendiente
        for prestamo in self.prestamos_lp:
            principal = prestamo.get('principal', 0)
            plazo = prestamo.get('plazo_a√±os', 5)
            a√±o_inicio = prestamo.get('a√±o_inicio', 1)
            a√±os_transcurridos = max(0, a√±o_actual - a√±o_inicio)
            
            if a√±os_transcurridos < plazo:
                if prestamo.get('metodo_amortizacion', 'frances') == 'frances':
                    tipo = prestamo.get('tipo_interes', 5.0)
                    saldo = self._saldo_prestamo_frances(principal, tipo, plazo, a√±os_transcurridos)
                else:  # Lineal
                    saldo = principal - (principal / plazo * a√±os_transcurridos)
                deuda += max(0, saldo)
        
        # Hipotecas - calcular saldo pendiente
        for hipoteca in self.hipotecas:
            principal = hipoteca.get('principal', 0)
            plazo = hipoteca.get('plazo_a√±os', 15)
            a√±o_inicio = hipoteca.get('a√±o_inicio', 1)
            a√±os_transcurridos = max(0, a√±o_actual - a√±o_inicio)
            
            if a√±os_transcurridos < plazo:
                tipo = hipoteca.get('tipo_interes', 3.0)
                saldo = self._saldo_prestamo_frances(principal, tipo, plazo, a√±os_transcurridos)
                deuda += max(0, saldo)
        
        # Leasings - calcular saldo pendiente
        for leasing in self.leasings:
            cuota_mensual = leasing.get('cuota_mensual', 0)
            meses_restantes_inicial = leasing.get('meses_restantes', leasing.get('plazo_meses', 48))
            
            # Calcular meses que han pasado desde el inicio de la proyecci√≥n
            meses_transcurridos_proyeccion = max(0, (a√±o_actual - 1) * 12)
            
            # Meses restantes actuales
            meses_restantes_actual = max(0, meses_restantes_inicial - meses_transcurridos_proyeccion)
            
            if meses_restantes_actual > 0:
                # Calcular saldo pendiente basado en cuotas restantes
                saldo = cuota_mensual * meses_restantes_actual * 0.9  # Factor de valor presente aproximado
                deuda += max(0, saldo)
        
        # P√≥lizas de cr√©dito (solo dispuesto actual)
        for poliza in self.polizas_credito:
            deuda += poliza.get('dispuesto', 0)
        
        return deuda

    def calcular_gastos_financieros_anuales(self, a√±o: int) -> float:
        """Calcula los gastos financieros totales para un a√±o"""
        gastos = 0
        
        # Pr√©stamos L/P con diferentes tipos de amortizaci√≥n
        for prestamo in self.prestamos_lp:
            principal = prestamo.get('principal', 0)
            tipo = prestamo.get('tipo_interes', 5.0)
            metodo = prestamo.get('metodo_amortizacion', 'frances')
            plazo = prestamo.get('plazo_a√±os', 5)
            a√±o_inicio = prestamo.get('a√±o_inicio', 1)
            
            if a√±o >= a√±o_inicio and a√±o < a√±o_inicio + plazo:
                if metodo == 'frances':
                    # Cuota constante
                    cuota = self._calcular_cuota_francesa(principal, tipo, plazo)
                    # Calcular intereses del a√±o
                    saldo_inicial = self._saldo_prestamo_frances(principal, tipo, plazo, a√±o - a√±o_inicio)
                    gastos += saldo_inicial * tipo / 100
                elif metodo == 'lineal':
                    # Amortizaci√≥n lineal
                    saldo = principal - (principal / plazo * (a√±o - a√±o_inicio))
                    gastos += saldo * tipo / 100
                elif metodo == 'bullet':
                    # Solo intereses hasta el final
                    gastos += principal * tipo / 100
        
        # Hipotecas (generalmente m√©todo franc√©s)
        for hipoteca in self.hipotecas:
            principal = hipoteca.get('principal', 0)
            tipo = hipoteca.get('tipo_interes', self.euribor + 1.0)
            plazo = hipoteca.get('plazo_a√±os', 15)
            a√±o_inicio = hipoteca.get('a√±o_inicio', 1)
            
            if a√±o >= a√±o_inicio and a√±o < a√±o_inicio + plazo:
                saldo_inicial = self._saldo_prestamo_frances(principal, tipo, plazo, a√±o - a√±o_inicio)
                gastos += saldo_inicial * tipo / 100
        
        # Leasings
        for leasing in self.leasings:
            cuota_mensual = leasing.get('cuota_mensual', 0)
            meses_restantes = leasing.get('meses_restantes', leasing.get('plazo_meses', 48))
            # Calcular meses en este a√±o
            meses_a√±o = min(12, max(0, meses_restantes - (a√±o - 1) * 12))
            gastos += cuota_mensual * meses_a√±o * 0.3  # Aproximadamente 30% es inter√©s
        
        # P√≥lizas de cr√©dito
        for poliza in self.polizas_credito:
            dispuesto = poliza.get('dispuesto', 0)
            tipo = poliza.get('tipo_interes', self.euribor + 2.5)
            gastos += dispuesto * tipo / 100  # Convertir porcentaje a decimal
        
        # Factoring
        if self.factoring:
            limite = self.factoring.get('limite', 0)
            coste = self.factoring.get('coste', 0.015)  # Ya viene como decimal de app.py
            # Asumimos uso del 80% del l√≠mite
            volumen_estimado = limite * 0.8
            gastos += volumen_estimado * coste
        
        return gastos

    def _calcular_cuota_francesa(self, principal: float, tipo: float, plazo: int) -> float:
        """Calcula la cuota del m√©todo franc√©s"""
        if tipo == 0:
            return principal / plazo
        r = tipo / 100
        return principal * (r * (1 + r)**plazo) / ((1 + r)**plazo - 1)

    def _saldo_prestamo_frances(self, principal: float, tipo: float, plazo: int, a√±os_transcurridos: int) -> float:
        """Calcula el saldo pendiente de un pr√©stamo franc√©s"""
        if a√±os_transcurridos >= plazo:
            return 0
        if tipo == 0:
            return principal * (1 - a√±os_transcurridos / plazo)
        
        r = tipo / 100
        cuota = self._calcular_cuota_francesa(principal, tipo, plazo)
        
        # Saldo = Principal * (1+r)^n - Cuota * ((1+r)^n - 1) / r
        factor = (1 + r) ** a√±os_transcurridos
        saldo = principal * factor - cuota * (factor - 1) / r
        
        return max(0, saldo)  
      
    def generar_proyecciones(self, a√±os: int = 5) -> dict:
        """
        Genera todas las proyecciones financieras
        """
        # Generar P&L
        self.generar_pyl(a√±os)
        
        # Generar Balance
        self.generar_balance(a√±os)
        
        # Generar Cash Flow
        self.generar_cash_flow(a√±os)
        
        # Calcular ratios
        self.calcular_ratios()
        
        # Realizar valoraci√≥n
        # valoracion = self.realizar_valoracion_bancainversion()  # Se hace despu√©s con McKinsey
        
        return {
            'pyl': self.pyl,
            'balance': self.balance,
            'cash_flow': self.cash_flow,
            'ratios': self.ratios,
            'valoracion': valoracion
        }
    
    def _get_crecimiento_sector(self) -> float:
        """Obtiene crecimiento esperado del sector"""
        crecimientos = {
            'Tecnolog√≠a': 0.15,
            'Hosteler√≠a': 0.06,
            'Automoci√≥n': 0.04,
            'Ecommerce': 0.09,
            'Consultor√≠a': 0.08,
            'Retail': 0.035,
            'Servicios': 0.05,
            'Industrial': 0.04,
            'Otro': 0.03
        }
        return crecimientos.get(self.sector, 0.03)

    def generar_pyl(self, a√±os: int = 5):
        """Genera la cuenta de resultados proyectada"""
        pyl = []
        
        for a√±o in range(1, a√±os + 1):
            print(f"\n=== PROCESANDO A√ëO {a√±o} ===")
            # Ingresos
            if a√±o == 1:
                # Aplicar crecimiento tambi√©n en el a√±o 1
                factor_macro = 1 + (self.pib_crecimiento - 2) / 100 * 0.3
                crecimiento_ajustado = self.crecimiento_por_a√±o[0] * factor_macro
                print(f"üîç DEBUG: ingresos_iniciales={self.ingresos_iniciales:,.0f}, factor_macro={factor_macro:.4f}")
                ingresos = self.ingresos_iniciales * (1 + crecimiento_ajustado / 100)
                print(f"DEBUG: A√±o {a√±o}, Ingresos calculados: {ingresos:,.0f}, Crecimiento ajustado: {crecimiento_ajustado}")
            else:
                # Crecimiento ajustado por inflaci√≥n y contexto macro
                factor_macro = 1 + (self.pib_crecimiento - 2) / 100 * 0.3  # 30% correlaci√≥n con PIB
                crecimiento_ajustado = self.crecimiento_por_a√±o[a√±o-1] * factor_macro
                ingresos = pyl[-1]['ingresos'] * (1 + crecimiento_ajustado / 100)
            
            # Costes operativos
            inflacion_acum = (1 + self.inflacion / 100) ** (a√±o - 1)
            print(f"DEBUG: Inflaci√≥n acum: {inflacion_acum}, Factor actividad siguiente...")

            # Coste de ventas como % de ingresos (viene de datos_empresa)
            coste_ventas = ingresos * self.costos_variables_pct

            # Gastos fijos ajustados por inflaci√≥n
            # Gastos seg√∫n estructura real del sector hosteler√≠a
            factor_actividad = ingresos / self.ingresos_iniciales
            
            # Determinar caracter√≠sticas de la empresa
            from datetime import datetime
            a√±os_operando = datetime.now().year - self.a√±o_fundacion
            es_empresa_madura = a√±os_operando > 15 or self.ingresos_iniciales > 50000000
            
            # Configuraci√≥n de eficiencias por sector
            eficiencias_sector = {
                'Industrial': {'personal': 0.15, 'general': 0.10, 'marketing': 0.40},
                'Tecnolog√≠a': {'personal': 0.25, 'general': 0.15, 'marketing': 0.50},
                'Retail': {'personal': 0.35, 'general': 0.20, 'marketing': 0.60},
                'Hosteler√≠a': {'personal': 0.40, 'general': 0.25, 'marketing': 0.50},
                'Ecommerce': {'personal': 0.20, 'general': 0.15, 'marketing': 0.70},
                'Servicios': {'personal': 0.30, 'general': 0.20, 'marketing': 0.50},
                'Consultor√≠a': {'personal': 0.45, 'general': 0.15, 'marketing': 0.40},
                'Automoci√≥n': {'personal': 0.20, 'general': 0.12, 'marketing': 0.45},
                'Otro': {'personal': 0.35, 'general': 0.20, 'marketing': 0.60}
            }
            
            # Obtener eficiencias del sector
            sector_key = self.sector if self.sector in eficiencias_sector else 'Otro'
            eficiencias = eficiencias_sector[sector_key]
            # Aplicar econom√≠as de escala si es empresa madura
            if es_empresa_madura:
                # Ajustar eficiencias seg√∫n escenario
                ajuste_escenario = 1.0
                if self.tipo_escenario == "Pesimista":
                    ajuste_escenario = 0.5  # Menos eficiencia en escenario pesimista
                elif self.tipo_escenario == "Optimista":
                    ajuste_escenario = 1.2  # M√°s eficiencia en escenario optimista
                    
                # Aplicar estructura sectorial para empresas maduras
                if self.sector == "Industrial" or self.sector == "Automoci√≥n":
                    # 50-70% variables (media: 60%)
                    gastos_personal = self.gastos_personal * (0.40 * inflacion_acum + 0.60 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.35 * inflacion_acum + 0.65 * factor_actividad)
                elif self.sector == "Tecnolog√≠a":
                    # 10-30% variables (media: 20%)
                    gastos_personal = self.gastos_personal * (0.80 * inflacion_acum + 0.20 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.75 * inflacion_acum + 0.25 * factor_actividad)
                elif self.sector == "Ecommerce":
                    # 60-80% variables (media: 70%)
                    gastos_personal = self.gastos_personal * (0.30 * inflacion_acum + 0.70 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.25 * inflacion_acum + 0.75 * factor_actividad)
                elif self.sector == "Hosteler√≠a":
                    # 55-65% variables (media: 60%)
                    gastos_personal = self.gastos_personal * (0.40 * inflacion_acum + 0.60 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.35 * inflacion_acum + 0.65 * factor_actividad)
                elif self.sector == "Retail":
                    # 55-70% variables (media: 62%)
                    gastos_personal = self.gastos_personal * (0.38 * inflacion_acum + 0.62 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.35 * inflacion_acum + 0.65 * factor_actividad)
                elif self.sector == "Consultor√≠a" or self.sector == "Servicios":
                    # 60-85% variables (media: 72%)
                    gastos_personal = self.gastos_personal * (0.28 * inflacion_acum + 0.72 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.60 * inflacion_acum + 0.40 * factor_actividad)
                else:
                    # Sector "Otro": usar factor_eficiencia original
                    factor_eficiencia_personal = 1 + (factor_actividad - 1) * eficiencias['personal'] * ajuste_escenario
                    gastos_personal = self.gastos_personal * factor_eficiencia_personal * inflacion_acum
                    factor_eficiencia_general = 1 + (factor_actividad - 1) * eficiencias['general'] * ajuste_escenario
                    gastos_generales = self.gastos_generales * factor_eficiencia_general * inflacion_acum
                
                # Marketing siempre es m√°s variable
                factor_eficiencia_marketing = 1 + (factor_actividad - 1) * eficiencias['marketing'] * ajuste_escenario
                gastos_marketing = self.gastos_marketing * factor_eficiencia_marketing * inflacion_acum
            else:
                # Empresas j√≥venes: ajustar sensibilidad seg√∫n escenario
                if self.tipo_escenario == "Pesimista":
                    # Mayor sensibilidad de costos en escenario pesimista
                    gastos_personal = self.gastos_personal * (0.75 * inflacion_acum + 0.45 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.85 * inflacion_acum + 0.30 * factor_actividad)
                    gastos_marketing = self.gastos_marketing * (0.30 * inflacion_acum + 0.50 * factor_actividad)
                elif self.tipo_escenario == "Optimista":
                    # Mejor control de costos en escenario optimista
                    gastos_personal = self.gastos_personal * (0.60 * inflacion_acum + 0.25 * factor_actividad)
                    gastos_generales = self.gastos_generales * (0.75 * inflacion_acum + 0.15 * factor_actividad)
                    gastos_marketing = self.gastos_marketing * (0.45 * inflacion_acum + 0.65 * factor_actividad)
                else:
                    # Escenario base: aplicar estructura sectorial tambi√©n a empresas j√≥venes
                    if self.sector == "Industrial" or self.sector == "Automoci√≥n":
                        gastos_personal = self.gastos_personal * (0.40 * inflacion_acum + 0.60 * factor_actividad)
                        gastos_generales = self.gastos_generales * (0.35 * inflacion_acum + 0.65 * factor_actividad)
                    elif self.sector == "Tecnolog√≠a":
                        gastos_personal = self.gastos_personal * (0.80 * inflacion_acum + 0.20 * factor_actividad)
                        gastos_generales = self.gastos_generales * (0.75 * inflacion_acum + 0.25 * factor_actividad)
                    elif self.sector == "Ecommerce":
                        gastos_personal = self.gastos_personal * (0.30 * inflacion_acum + 0.70 * factor_actividad)
                        gastos_generales = self.gastos_generales * (0.25 * inflacion_acum + 0.75 * factor_actividad)
                    elif self.sector == "Hosteler√≠a":
                        gastos_personal = self.gastos_personal * (0.40 * inflacion_acum + 0.60 * factor_actividad)
                        gastos_generales = self.gastos_generales * (0.35 * inflacion_acum + 0.65 * factor_actividad)
                    elif self.sector == "Retail":
                        gastos_personal = self.gastos_personal * (0.38 * inflacion_acum + 0.62 * factor_actividad)
                        gastos_generales = self.gastos_generales * (0.35 * inflacion_acum + 0.65 * factor_actividad)
                    elif self.sector == "Consultor√≠a" or self.sector == "Servicios":
                        gastos_personal = self.gastos_personal * (0.28 * inflacion_acum + 0.72 * factor_actividad)
                        gastos_generales = self.gastos_generales * (0.60 * inflacion_acum + 0.40 * factor_actividad)
                    else:
                        # Sector "Otro": valores conservadores
                        gastos_personal = self.gastos_personal * (0.65 * inflacion_acum + 0.35 * factor_actividad)
                        gastos_generales = self.gastos_generales * (0.80 * inflacion_acum + 0.20 * factor_actividad)
                    
                    # Marketing m√°s variable
                    gastos_marketing = self.gastos_marketing * (0.40 * inflacion_acum + 0.60 * factor_actividad)
            # Total otros gastos
            otros_gastos = gastos_generales + gastos_marketing
            
            # Calcular EBITDA correctamente para todos los a√±os
            # Calcular EBITDA = Ventas - Costos - Gastos
            ebitda = ingresos - coste_ventas - gastos_personal - otros_gastos
            margen_ebitda = (ebitda / ingresos * 100) if ingresos > 0 else 0

            
            # Amortizaciones (activo fijo + CAPEX acumulado)
            amortizacion = (self.activo_fijo_inicial + sum([c['importe'] for c in self.plan_capex if c['a√±o'] < a√±o])) / 10
            
            # EBIT
            ebit = ebitda - amortizacion
            
            # Gastos financieros
            gastos_financieros = self.calcular_gastos_financieros_anuales(a√±o)
            
            # BAI y Beneficio Neto
            bai = ebit - gastos_financieros
            impuestos = max(0, bai * self.tasa_impuestos / 100)
            beneficio_neto = bai - impuestos
            
            pyl.append({
                'a√±o': a√±o,
                'ingresos': ingresos,
                'coste_ventas': coste_ventas,
                'margen_bruto': ingresos - coste_ventas,
                'gastos_personal': gastos_personal,
                'otros_gastos': otros_gastos,
                'ebitda': ebitda,
                'margen_ebitda_%': margen_ebitda,
                'amortizacion': amortizacion,
                'ebit': ebit,
                'gastos_financieros': gastos_financieros,
                'bai': bai,
                'impuestos': impuestos,
                'beneficio_neto': beneficio_neto
            })
        # Debug final antes de crear DataFrame
        print("\n=== DEBUG PYL FINAL ===")
        for i, a√±o_data in enumerate(pyl):
        
            self.pyl = pd.DataFrame(pyl)

    def generar_balance(self, a√±os: int = 5):
        """
        Genera el balance proyectado - M√©todo McKinsey
        Integrado con P&L y respetando l√≠mites de endeudamiento
        """
        balances = []
        
        
        # Balance inicial (a√±o 0)
        activo_fijo_neto_anterior = self.activo_fijo_neto_inicial
        patrimonio_neto_anterior = self.capital_social + self.reserva_legal + self.reservas + self.resultados_acumulados
        tesoreria_anterior = self.tesoreria_inicial if hasattr(self, 'tesoreria_inicial') else 0
        
        # Deuda inicial
        deuda_total_anterior = 0
        for prestamo in self.prestamos_lp:
            deuda_total_anterior += prestamo['principal']
        
        for a√±o in range(1, a√±os + 1):
            # 1. DATOS DEL P&L
            pyl_a√±o = self.pyl[self.pyl['a√±o'] == a√±o]
            ingresos = pyl_a√±o['ingresos'].values[0]
            ebitda = pyl_a√±o['ebitda'].values[0]
            beneficio_neto = pyl_a√±o['beneficio_neto'].values[0]
            amortizacion = pyl_a√±o['amortizacion'].values[0]
            gastos_financieros = pyl_a√±o['gastos_financieros'].values[0]
            
            # 2. WORKING CAPITAL (d√≠as de operaci√≥n)
            clientes = ingresos * self.dias_cobro / 365
            inventario = ingresos * self.costos_variables_pct * self.dias_inventario / 365
            proveedores = ingresos * self.costos_variables_pct * self.dias_pago / 365
            
            # 3. ACTIVO FIJO
            capex_a√±o = 0
            for capex in self.plan_capex:
                if capex['a√±o'] == a√±o:
                    capex_a√±o = capex['importe']
                    break
            
            activo_fijo_neto = activo_fijo_neto_anterior + capex_a√±o - amortizacion
            
            # ACTIVOS INTANGIBLES con inversi√≥n y amortizaci√≥n
            if a√±o == 1:
                activos_intangibles_bruto_anterior = self.activos_intangibles_inicial
                amortizacion_intangibles_acumulada_anterior = 0
                
                # DIAGN√ìSTICO TECHSTART
            
            # Inversi√≥n en intangibles seg√∫n sector
            pct_inversion_intangibles = INVERSION_INTANGIBLES_SECTOR.get(self.sector, 0.8)
            inversion_intangibles = ingresos * pct_inversion_intangibles / 100
            
            # Amortizaci√≥n anual
            activos_intangibles_bruto = activos_intangibles_bruto_anterior + inversion_intangibles
            amortizacion_intangibles_anual = activos_intangibles_bruto * AMORTIZACION_INTANGIBLES_ANUAL
            amortizacion_intangibles_acumulada = amortizacion_intangibles_acumulada_anterior + amortizacion_intangibles_anual
            activos_intangibles = max(0, activos_intangibles_bruto - amortizacion_intangibles_acumulada)
            
            # INVERSIONES LP - gesti√≥n profesional de tesorer√≠a
            # NOTA: Inversiones LP son activos financieros (bonos, participaciones),
            # NO activo fijo (eso es CAPEX y va en Activo Fijo Neto)
            
            # Basado en pol√≠tica de tesorer√≠a por fase empresarial
            multiple_objetivo = TESORERIA_OBJETIVO_MULTIPLE.get(self.fase_empresa, 1.5)
            
            if a√±o > 1:  # Desde el a√±o 2 evaluamos excesos
                # Calcular exceso sobre el objetivo de tesorer√≠a
                tesoreria_objetivo = tesoreria_minima * multiple_objetivo
                exceso_tesoreria = tesoreria_anterior - tesoreria_objetivo
                
                # DIAGN√ìSTICO - Imprimir c√°lculos
                print(f"\n=== DIAGN√ìSTICO TESORER√çA A√±o {a√±o} ===")
                print(f"Empresa: {self.nombre} - Fase: {self.fase_empresa}")
                print(f"Tesorer√≠a anterior: ‚Ç¨{tesoreria_anterior:,.0f}")
                print(f"Tesorer√≠a m√≠nima: ‚Ç¨{tesoreria_minima:,.0f}")
                print(f"M√∫ltiplo objetivo: {multiple_objetivo}x")
                print(f"Tesorer√≠a objetivo: ‚Ç¨{tesoreria_objetivo:,.0f}")
                print(f"Exceso/d√©ficit: ‚Ç¨{exceso_tesoreria:,.0f}")
                
                # Determinar ajuste en inversiones LP seg√∫n situaci√≥n de tesorer√≠a
                if exceso_tesoreria > 0:
                    # Hay exceso: considerar inversi√≥n adicional
                    inversion_lp_adicional = calcular_inversion_lp_adicional(
                        exceso_tesoreria, ingresos, self.fase_empresa
                    )
                    inversiones_lp = self.inversiones_lp_inicial + inversion_lp_adicional
                    print(f"Inversi√≥n LP adicional: ‚Ç¨{inversion_lp_adicional:,.0f}")
                else:
                    # Hay d√©ficit: considerar liquidaci√≥n de inversiones LP
                    deficit_a_cubrir = abs(exceso_tesoreria)
                    
                    # Liquidar inversiones LP existentes para cubrir el d√©ficit
                    # Pero mantener un m√≠nimo del 20% como reserva estrat√©gica
                    lp_disponible_liquidar = self.inversiones_lp_inicial * 0.8
                    liquidacion_lp = min(deficit_a_cubrir * 0.7, lp_disponible_liquidar)  # Liquidar hasta 70% del d√©ficit
                    
                    inversiones_lp = self.inversiones_lp_inicial - liquidacion_lp
                    
                    print(f"D√âFICIT de tesorer√≠a: ‚Ç¨{deficit_a_cubrir:,.0f}")
                    print(f"Liquidaci√≥n de inversiones LP: ‚Ç¨{liquidacion_lp:,.0f}")
                    
                print(f"Inversiones LP totales: ‚Ç¨{inversiones_lp:,.0f}")
                print("="*40)
            else:
                inversiones_lp = self.inversiones_lp_inicial
                
            # OTROS ACTIVOS NC - proporcionales a la actividad
            # Incluye fianzas, dep√≥sitos, derechos de uso, activos fiscales diferidos
            otros_activos_nc = ingresos * 0.001  # 0.1% de ventas
            
            # INVERSIONES CP - usar valor inicial por ahora (se recalcular√° despu√©s)
            inversiones_cp = self.inversiones_cp_inicial  # Valor temporal
            
            # GASTOS ANTICIPADOS - proporcional a gastos operativos
            gastos_operativos_totales = (pyl_a√±o['gastos_personal'].values[0] + 
                                       pyl_a√±o['otros_gastos'].values[0])
            gastos_anticipados = gastos_operativos_totales * GASTOS_ANTICIPADOS_PCT_GASTOS
            
            # Otros
            otros_activos_corrientes = self.otros_activos_corrientes_inicial
            otros_activos = ingresos * 0.02
            
            # 4. DEUDA - Sistema franc√©s con l√≠mites McKinsey
            deuda_cp_base = 0
            deuda_lp_base = 0
            
            # Amortizaci√≥n de deuda existente
            for prestamo in self.prestamos_lp:
                saldo_actual = self._calcular_saldo_deuda_a√±o(prestamo, a√±o)
                saldo_proximo = self._calcular_saldo_deuda_a√±o(prestamo, a√±o + 1)
                
                cp_prestamo = max(0, saldo_actual - saldo_proximo)
                lp_prestamo = max(0, saldo_proximo)
                
                deuda_cp_base += cp_prestamo
                deuda_lp_base += lp_prestamo
            
            deuda_total_base = deuda_cp_base + deuda_lp_base
            
            # Verificar l√≠mite de endeudamiento
            ratio_deuda_ebitda = deuda_total_base / ebitda if ebitda > 0 else 0
            deuda_maxima = ebitda * self.limite_deuda_ebitda
            
            # 5. PATRIMONIO NETO
            # Dividendos seg√∫n pol√≠tica
            dividendos = beneficio_neto * self.payout_ratio if beneficio_neto > 0 else 0
            patrimonio_neto = patrimonio_neto_anterior + beneficio_neto - dividendos
            
            # Otros pasivos
            otros_pasivos = ingresos * 0.03
            
            # 6. CALCULAR NECESIDADES DE FINANCIACI√ìN
            total_activo_sin_tesoreria = (
                activo_fijo_neto + activos_intangibles + inversiones_lp + otros_activos_nc +
                clientes + inventario + inversiones_cp + gastos_anticipados + 
                otros_activos_corrientes + otros_activos
            )
            
            # Tesorer√≠a m√≠nima - benchmark sectorial m√°s realista
            # Opci√≥n 1: % de ventas (m√°s com√∫n en la pr√°ctica)
            tesoreria_minima_pct = 0.025  # 2.5% de ventas para industrial
            tesoreria_minima_ventas = ingresos * tesoreria_minima_pct
            
            # Opci√≥n 2: d√≠as de gastos operativos (m√°ximo 15 d√≠as)
            gastos_operativos_diarios = (pyl_a√±o['coste_ventas'].values[0] + 
                                        pyl_a√±o['gastos_personal'].values[0] + 
                                        pyl_a√±o['otros_gastos'].values[0]) / 365
            tesoreria_minima_dias = gastos_operativos_diarios * 15  # 15 d√≠as m√°ximo
            
            # Usar el menor de ambos c√°lculos (m√°s conservador)
            tesoreria_minima = min(tesoreria_minima_ventas, tesoreria_minima_dias)
            
            # Balance objetivo
            pasivo_sin_deuda = proveedores + otros_pasivos
            activo_total_objetivo = total_activo_sin_tesoreria + tesoreria_minima
            
            # Necesidad de financiaci√≥n
            necesidad_financiacion = activo_total_objetivo - pasivo_sin_deuda - patrimonio_neto
            
            # 7. OPTIMIZACI√ìN DE ESTRUCTURA DE CAPITAL
            if necesidad_financiacion > deuda_total_base:
                # Necesitamos m√°s financiaci√≥n
                deuda_adicional_necesaria = necesidad_financiacion - deuda_total_base
                
                # Verificar si podemos tomar m√°s deuda
                deuda_total_nueva = deuda_total_base + deuda_adicional_necesaria
                ratio_nuevo = deuda_total_nueva / ebitda if ebitda > 0 else 999
                
                if ratio_nuevo <= self.limite_deuda_ebitda:
                    # Podemos financiar con deuda
                    deuda_cp = deuda_cp_base + deuda_adicional_necesaria * 0.2  # 20% CP
                    deuda_lp = deuda_lp_base + deuda_adicional_necesaria * 0.8  # 80% LP
                    tesoreria = tesoreria_minima
                else:
                    # L√≠mite de deuda alcanzado
                    deuda_total_max = deuda_maxima
                    deuda_adicional_posible = max(0, deuda_total_max - deuda_total_base)
                    
                    deuda_cp = deuda_cp_base + deuda_adicional_posible * 0.2
                    deuda_lp = deuda_lp_base + deuda_adicional_posible * 0.8
                    
                    # El resto debe venir de equity o reducir tesorer√≠a
                    gap_financiacion = necesidad_financiacion - (deuda_cp + deuda_lp)
                    
                    if gap_financiacion > 0:
                        # Necesitar√≠amos m√°s equity (ampliaci√≥n de capital)
                        # Por simplicidad, ajustamos tesorer√≠a al m√≠nimo absoluto
                        tesoreria = max(ingresos * 0.01, tesoreria_minima - gap_financiacion)
                    else:
                        tesoreria = tesoreria_minima
            else:
                # Tenemos exceso de financiaci√≥n, reducir deuda si es posible
                exceso = deuda_total_base - necesidad_financiacion
                
                if exceso > 0 and deuda_lp_base > exceso:
                    deuda_lp = deuda_lp_base - exceso
                    deuda_cp = deuda_cp_base
                else:
                    deuda_cp = deuda_cp_base
                    deuda_lp = deuda_lp_base
                
                tesoreria = tesoreria_minima
            
            # Recalcular totales finales
            total_pasivo_pn = deuda_cp + deuda_lp + proveedores + otros_pasivos + patrimonio_neto
            # Calcular inversiones CP basadas en tesorer√≠a disponible
            inversiones_cp = tesoreria * INVERSIONES_CP_PCT_TESORERIA
            
            # Recalcular totales con inversiones_cp actualizadas
            total_activo_sin_tesoreria = (
                activo_fijo_neto + activos_intangibles + inversiones_lp + otros_activos_nc +
                clientes + inventario + inversiones_cp + gastos_anticipados + 
                otros_activos_corrientes + otros_activos
            )
            
            total_activo = total_activo_sin_tesoreria + tesoreria
            
            # Ajuste final si es necesario
            if abs(total_activo - total_pasivo_pn) > 0.01:
                tesoreria += (total_pasivo_pn - total_activo)
                total_activo = total_pasivo_pn
            
            # PREVENIR TESORER√çA NEGATIVA
            if tesoreria < 0:
                # Calcular financiaci√≥n adicional m√≠nima necesaria
                gastos_diarios = gastos_operativos_diarios if 'gastos_operativos_diarios' in locals() else (ingresos * 0.7 / 365)
                tesoreria_minima_seguridad = gastos_diarios * 5  # 5 d√≠as de gastos
                deficit = abs(tesoreria) + tesoreria_minima_seguridad
                
                print(f"\nA√ëO {a√±o} - {self.nombre}: Tesorer√≠a negativa detectada")
                print(f"  Tesorer√≠a antes: ‚Ç¨{tesoreria:,.0f}")
                print(f"  D√©ficit a cubrir: ‚Ç¨{deficit:,.0f}")
                
                # Generar deuda CP adicional
                deuda_cp += deficit
                
                # Ajustar tesorer√≠a al m√≠nimo de seguridad
                tesoreria = tesoreria_minima_seguridad
                
                # Recalcular totales
                total_pasivo_pn = deuda_cp + deuda_lp + proveedores + otros_pasivos + patrimonio_neto
                total_activo = total_activo_sin_tesoreria + tesoreria
                
                print(f"  Deuda CP adicional: ‚Ç¨{deficit:,.0f}")
                print(f"  Nueva deuda CP: ‚Ç¨{deuda_cp:,.0f}")
                print(f"  Tesorer√≠a final: ‚Ç¨{tesoreria:,.0f}")
            
            # Guardar balance
            # DIAGN√ìSTICO - Imprimir valores para La Terraza
            if self.nombre and "Terraza" in self.nombre and a√±o == 1:
                print(f"\n=== DIAGN√ìSTICO BALANCE LA TERRAZA A√ëO 1 ===")
                print(f"Activo Fijo Neto: {activo_fijo_neto:,.2f}")
                print(f"Tesorer√≠a: {tesoreria:,.2f}")
                print(f"Total Activo: {total_activo:,.2f}")
                print("="*50)
            
            balances.append({
                'a√±o': a√±o,
                # Activos
                'activo_fijo_neto': activo_fijo_neto,
                'activos_intangibles': activos_intangibles,
                'inversiones_lp': inversiones_lp,
                'otros_activos_nc': otros_activos_nc,
                'tesoreria': tesoreria,
                'clientes': clientes,
                'inventario': inventario,
                'inversiones_cp': inversiones_cp,
                'gastos_anticipados': gastos_anticipados,
                'otros_activos_corrientes': otros_activos_corrientes,
                'otros_activos': otros_activos,
                'total_activo': total_activo,
                # Pasivos
                'proveedores': proveedores,
                'deuda_cp': deuda_cp,
                'deuda_lp': deuda_lp,
                'otros_pasivos': otros_pasivos,
                # Patrimonio
                'capital': self.capital_social,
                'reservas': patrimonio_neto - self.capital_social,
                'patrimonio_neto': patrimonio_neto,
                'total_pasivo_pn': total_pasivo_pn,
                # M√©tricas McKinsey
                'ratio_deuda_ebitda': (deuda_cp + deuda_lp) / ebitda if ebitda > 0 else 0,
                'cobertura_intereses': ebitda / gastos_financieros if gastos_financieros > 0 else 999
            })
            
            # Actualizar para siguiente a√±o
            activo_fijo_neto_anterior = activo_fijo_neto
            patrimonio_neto_anterior = patrimonio_neto
            activos_intangibles_bruto_anterior = activos_intangibles_bruto
            amortizacion_intangibles_acumulada_anterior = amortizacion_intangibles_acumulada
            tesoreria_anterior = tesoreria
        
        self.balance = pd.DataFrame(balances)
    
    def _calcular_saldo_deuda_a√±o(self, prestamo: dict, a√±o: int) -> float:
        """Calcula el saldo pendiente de un pr√©stamo en un a√±o dado"""
        principal = prestamo.get('principal', 0)
        tipo = prestamo.get('tipo_interes', 5.0)
        plazo = prestamo.get('plazo_a√±os', 5)
        a√±o_inicio = prestamo.get('a√±o_inicio', 1)
        metodo = prestamo.get('metodo_amortizacion', 'frances')
        
        a√±os_transcurridos = a√±o - a√±o_inicio
        
        if a√±os_transcurridos < 0:
            return principal
        if a√±os_transcurridos >= plazo:
            return 0
        
        if metodo == 'frances':
            return self._saldo_prestamo_frances(principal, tipo, plazo, a√±os_transcurridos)
        elif metodo == 'lineal':
            return principal - (principal / plazo * a√±os_transcurridos)
        elif metodo == 'bullet':
            return principal if a√±os_transcurridos < plazo else 0
        
        return 0  

    def generar_cash_flow(self, a√±os: int = 5):
        """Genera el estado de flujos de caja"""
        cash_flows = []
        
        for a√±o in range(1, a√±os + 1):
            # Flujo operativo
            ebitda = self.pyl[self.pyl['a√±o'] == a√±o]['ebitda'].values[0]
            impuestos_pagados = self.pyl[self.pyl['a√±o'] == a√±o]['impuestos'].values[0]
            
            # Variaci√≥n capital circulante
            if a√±o == 1:
                var_clientes = self.balance[self.balance['a√±o'] == a√±o]['clientes'].values[0] - self.clientes_inicial
                var_inventario = self.balance[self.balance['a√±o'] == a√±o]['inventario'].values[0] - self.inventario_inicial
                var_proveedores = self.balance[self.balance['a√±o'] == a√±o]['proveedores'].values[0] - self.proveedores_inicial
            else:
                var_clientes = (self.balance[self.balance['a√±o'] == a√±o]['clientes'].values[0] - 
                            self.balance[self.balance['a√±o'] == a√±o-1]['clientes'].values[0])
                var_inventario = (self.balance[self.balance['a√±o'] == a√±o]['inventario'].values[0] - 
                                self.balance[self.balance['a√±o'] == a√±o-1]['inventario'].values[0])
                var_proveedores = (self.balance[self.balance['a√±o'] == a√±o]['proveedores'].values[0] - 
                                self.balance[self.balance['a√±o'] == a√±o-1]['proveedores'].values[0])

            # DEBUG - Capital de trabajo
            if a√±o == 1:
                print(f"\n=== DEBUG CAPITAL TRABAJO A√ëO 1 ===")
                print(f"Clientes a√±o 1: ‚Ç¨{self.balance[self.balance['a√±o'] == a√±o]['clientes'].values[0]:,.0f}")
                print(f"Clientes inicial: ‚Ç¨{self.clientes_inicial:,.0f}")
                print(f"Var clientes: ‚Ç¨{var_clientes:,.0f}")
                print(f"Inventario a√±o 1: ‚Ç¨{self.balance[self.balance['a√±o'] == a√±o]['inventario'].values[0]:,.0f}")
                print(f"Inventario inicial: ‚Ç¨{self.inventario_inicial:,.0f}")
                print(f"Var inventario: ‚Ç¨{var_inventario:,.0f}")
                print(f"Proveedores a√±o 1: ‚Ç¨{self.balance[self.balance['a√±o'] == a√±o]['proveedores'].values[0]:,.0f}")
                print(f"Var proveedores: ‚Ç¨{var_proveedores:,.0f}")

            var_nok = - (var_clientes + var_inventario - var_proveedores)   
            
            flujo_operativo = ebitda - impuestos_pagados + var_nok

            # Flujo de inversi√≥n
            # CAPEX: usar plan del usuario o porcentaje por sector
            capex_planificado = sum([c['importe'] for c in self.plan_capex if c['a√±o'] == a√±o])
            if capex_planificado > 0:
                capex_a√±o = capex_planificado
            else:
                # Porcentajes de CAPEX por sector
                CAPEX_POR_SECTOR = {
                    'hosteler√≠a': 0.06,
                    'tecnolog√≠a': 0.03,
                    'ecommerce': 0.025,
                    'consultor√≠a': 0.02,
                    'retail': 0.05,
                    'servicios': 0.035,
                    'automoci√≥n': 0.08,
                    'industrial': 0.10,
                    'otro': 0.04
                }
                porcentaje = CAPEX_POR_SECTOR.get(self.sector.lower(), 0.04)
                ventas_a√±o = self.pyl[self.pyl['a√±o'] == a√±o]['ingresos'].values[0]
                capex_a√±o = ventas_a√±o * porcentaje
            flujo_inversion = -capex_a√±o
            
            # Flujo financiero
            gastos_financieros = self.pyl[self.pyl['a√±o'] == a√±o]['gastos_financieros'].values[0]
            
            # Amortizaciones de principal
            amort_principal = 0
            for prestamo in self.prestamos_lp:
                if prestamo['metodo_amortizacion'] == 'lineal':
                    amort_principal += prestamo['principal'] / prestamo['plazo_a√±os']
                elif prestamo['metodo_amortizacion'] == 'frances':
                    cuota = self._calcular_cuota_francesa(
                        prestamo['principal'], 
                        prestamo['tipo_interes'], 
                        prestamo['plazo_a√±os']
                    )
                    amort_principal += cuota - gastos_financieros * (prestamo['principal'] / max(self.calcular_deuda_total(a√±o), 1))
            
            # Dividendos
            if a√±o > 1:
                bn_anterior = self.pyl[self.pyl['a√±o'] == a√±o-1]['beneficio_neto'].values[0]
                dividendos = bn_anterior * self.dividendos_payout / 100 if bn_anterior > 0 else 0
            else:
                dividendos = 0
            
            flujo_financiero = -gastos_financieros - amort_principal - dividendos
            
            # Flujo de caja libre (para valoraci√≥n)
            fcf = flujo_operativo + flujo_inversion
            
            # Flujo total
            flujo_total = flujo_operativo + flujo_inversion + flujo_financiero
            
            cash_flows.append({
                'a√±o': a√±o,
                'flujo_operativo': flujo_operativo,
                'flujo_inversion': flujo_inversion,
                'flujo_financiero': flujo_financiero,
                'flujo_total': flujo_total,
                'free_cash_flow': fcf
            })
        
        self.cash_flow = pd.DataFrame(cash_flows)

    def calcular_ratios(self):
        """Calcula ratios financieros clave"""
        ratios = []
        
        for a√±o in range(1, len(self.pyl) + 1):
            # Datos del a√±o
            ingresos = self.pyl[self.pyl['a√±o'] == a√±o]['ingresos'].values[0]
            ebitda = self.pyl[self.pyl['a√±o'] == a√±o]['ebitda'].values[0]
            beneficio_neto = self.pyl[self.pyl['a√±o'] == a√±o]['beneficio_neto'].values[0]
            
            total_activo = self.balance[self.balance['a√±o'] == a√±o]['total_activo'].values[0]
            patrimonio_neto = self.balance[self.balance['a√±o'] == a√±o]['patrimonio_neto'].values[0]
            deuda_total = (self.balance[self.balance['a√±o'] == a√±o]['deuda_lp'].values[0] + 
                        self.balance[self.balance['a√±o'] == a√±o]['deuda_cp'].values[0])
            
            # Ratios de rentabilidad
            margen_ebitda = ebitda / ingresos * 100
            margen_neto = beneficio_neto / ingresos * 100
            roe = beneficio_neto / patrimonio_neto * 100 if patrimonio_neto > 0 else 0
            roa = beneficio_neto / total_activo * 100
            rotacion_activos = ingresos / total_activo if total_activo > 0 else 0

            # Obtener EBIT del P&L
            ebit = self.pyl[self.pyl['a√±o'] == a√±o]['ebit'].values[0]

            # ROCE (Return on Capital Employed)
            pasivo_corriente = (self.balance[self.balance['a√±o'] == a√±o]['deuda_cp'].values[0] +
                               self.balance[self.balance['a√±o'] == a√±o]['proveedores'].values[0])
            capital_empleado = total_activo - pasivo_corriente
            roce = ebit / capital_empleado * 100 if capital_empleado > 0 else 0

            # Ratios de solvencia
            ratio_endeudamiento = deuda_total / patrimonio_neto if patrimonio_neto > 0 else 0
            ratio_cobertura_intereses = ebitda / self.pyl[self.pyl['a√±o'] == a√±o]['gastos_financieros'].values[0] if self.pyl[self.pyl['a√±o'] == a√±o]['gastos_financieros'].values[0] > 0 else 999
            deuda_neta_ebitda = (deuda_total - self.balance[self.balance['a√±o'] == a√±o]['tesoreria'].values[0]) / ebitda if ebitda > 0 else 999
            
            # Ratios de liquidez
            activo_corriente = (self.balance[self.balance['a√±o'] == a√±o]['clientes'].values[0] +
                            self.balance[self.balance['a√±o'] == a√±o]['inventario'].values[0] +
                            self.balance[self.balance['a√±o'] == a√±o]['tesoreria'].values[0])
            pasivo_corriente = (self.balance[self.balance['a√±o'] == a√±o]['deuda_cp'].values[0] +
                            self.balance[self.balance['a√±o'] == a√±o]['proveedores'].values[0])
            
            ratio_liquidez = activo_corriente / pasivo_corriente if pasivo_corriente > 0 else 999
            
            ratios.append({
                'a√±o': a√±o,
                'margen_ebitda_%': margen_ebitda,
                'margen_neto_%': margen_neto,
                'roe_%': roe,
                'roa_%': roa,
                'rotacion_activos': rotacion_activos,
                'roce_%': roce,
                'ratio_endeudamiento': ratio_endeudamiento,
                'cobertura_intereses': ratio_cobertura_intereses,
                'deuda_neta_ebitda': deuda_neta_ebitda,
                'ratio_liquidez': ratio_liquidez
            })
        
        self.ratios = pd.DataFrame(ratios)

    def realizar_valoracion(self) -> dict:
        """Realiza la valoraci√≥n completa de la empresa con metodolog√≠a mejorada"""
        
        # Importar la nueva clase
#         from valoracion_profesional_v2 import ValoracionProfesionalMejorada
        
        # Crear instancia del valorador mejorado
#         valorador_mejorado = ValoracionProfesionalMejorada()
        
        # Preparar datos para valoraci√≥n
        empresa_info = {
            'sector': self.sector,
            'a√±o_fundacion': self.a√±o_fundacion,
            'cliente_principal_pct': 20,  # Asumimos 20% por defecto
            'equipo_directivo_a√±os_exp': 10  # Asumimos 10 a√±os por defecto
        }
        
        # Par√°metros financieros
        params_financieros = {
            'ingresos_ultimo_a√±o': self.pyl['ingresos'].iloc[-1] if self.pyl is not None else self.ingresos_iniciales,
            'margen_ebitda': self.pyl['margen_ebitda_%'].iloc[-1] if self.pyl is not None else self.margen_ebitda_inicial,
            'rating': self.rating_crediticio,
            'deuda_total': self.calcular_deuda_total(self.pyl['a√±o'].max() if self.pyl is not None else 5),
            'equity_total': self.balance['patrimonio_neto'].iloc[-1] if self.balance is not None else self.capital_social,
            'tasa_impuestos': self.tasa_impuestos
        }
        
        # 1. Calcular WACC mejorado
        wacc, detalles_wacc = valorador_mejorado.calcular_wacc_completo(empresa_info, params_financieros)
        
        # 2. Calcular tasa de crecimiento terminal
        g = valorador_mejorado.calcular_tasa_crecimiento_terminal(self.sector)
        
        # 3. Obtener flujos de caja
        flujos_caja = self.cash_flow['free_cash_flow'].tolist() if self.cash_flow is not None else []
        
        # 4. Calcular deuda neta
        deuda_total = self.calcular_deuda_total(1)  # A√±o inicial para valoraci√≥n
        tesoreria = self.balance['tesoreria'].iloc[-1] if self.balance is not None else self.tesoreria_inicial
        deuda_neta = deuda_total - tesoreria
        
        # 5. Realizar valoraci√≥n DCF
        valoracion_dcf = valorador_mejorado.realizar_valoracion_dcf(
            flujos_caja, wacc, g, deuda_neta
        )
        
        # 6. An√°lisis de sensibilidad
        caso_base = {'wacc': wacc, 'g': g}
        tabla_sensibilidad = valorador_mejorado.analisis_sensibilidad_bidimensional(
            caso_base, flujos_caja, deuda_neta
        )
        
        # 7. Valoraci√≥n por m√∫ltiplos (mantener compatibilidad)
        ebitda_ultimo = self.pyl['ebitda'].iloc[-1] if self.pyl is not None else 0
        multiplo_sector = {
            'Tecnolog√≠a': 15.0, 'Hosteler√≠a': 8.0, 'Ecommerce': 12.0,
            'Consultor√≠a': 10.0, 'Retail': 7.0, 'Servicios': 9.0,
            'Industrial': 8.0, 'Automoci√≥n': 7.0, 'Otro': 9.0
        }.get(self.sector, 9.0)
        
        valoracion_multiplos = {
            'valor_empresa': ebitda_ultimo * multiplo_sector,
            'valor_equity': ebitda_ultimo * multiplo_sector - deuda_neta,
            'multiplo_aplicado': multiplo_sector,
            'ebitda_base': ebitda_ultimo
        }
        
        # 8. Preparar resultado completo
        resultado = {
            # WACC y componentes
            'wacc_detalle': detalles_wacc,
            
            # Valoraci√≥n DCF
            'valoracion_dcf': valoracion_dcf,
            
            # Valoraci√≥n por m√∫ltiplos
            'valoracion_multiplos': valoracion_multiplos,
            
            # TIR esperada (simplificada)
            'tir_esperada': ((valoracion_dcf['equity_value'] / params_financieros['equity_total']) ** (1/5) - 1) * 100 if params_financieros['equity_total'] > 0 else 0,
            
            # An√°lisis de sensibilidad
            'analisis_sensibilidad': {
                'wacc_-2%': tabla_sensibilidad.iloc[0, 2] if len(tabla_sensibilidad) > 0 else 0,
                'wacc_-1%': tabla_sensibilidad.iloc[1, 2] if len(tabla_sensibilidad) > 1 else 0,
                'wacc_base': valoracion_dcf['equity_value'],
                'wacc_+1%': tabla_sensibilidad.iloc[3, 2] if len(tabla_sensibilidad) > 3 else 0,
                'wacc_+2%': tabla_sensibilidad.iloc[4, 2] if len(tabla_sensibilidad) > 4 else 0,
            },
            
            # Rating impl√≠cito
            'rating_implicito': self.rating_crediticio,
            
            # M√©tricas adicionales para transparencia
            'tasa_crecimiento_g': g * 100,
            'wacc': wacc * 100,
            'prima_tama√±o': detalles_wacc['prima_tama√±o'],
            'prima_especifica': detalles_wacc['prima_especifica']
        }
        
        return resultado   

    def calcular_metricas_clave(self, pyl_df: pd.DataFrame) -> Dict:
        """
        Calcula m√©tricas financieras clave del negocio
        """
        metricas = {
            'crecimiento_ventas_promedio': 0,
            'margen_ebitda_promedio': 0,
            'roi_proyectado': 0,
            'punto_equilibrio_a√±o': 0,
            'valor_empresa_estimado': 0
        }
        
        # Crecimiento promedio de ventas
        ventas = pyl_df['Ventas'].values
        crecimientos = [(ventas[i] - ventas[i-1]) / ventas[i-1] * 100 
                       for i in range(1, len(ventas))]
        metricas['crecimiento_ventas_promedio'] = round(sum(crecimientos) / len(crecimientos), 1)
        
        # Margen EBITDA promedio
        metricas['margen_ebitda_promedio'] = round(pyl_df['EBITDA %'].mean(), 1)
        
        # ROI simple (beneficio a√±o 5 / inversi√≥n inicial estimada)
        beneficio_a√±o_5 = pyl_df['Beneficio Neto'].iloc[-1]
        inversion_estimada = ventas[0] * 0.2  # 20% de ventas a√±o 1
        metricas['roi_proyectado'] = round(beneficio_a√±o_5 / inversion_estimada * 100, 1)
        
        # Punto de equilibrio (primer a√±o con beneficio positivo)
        for idx, beneficio in enumerate(pyl_df['Beneficio Neto']):
            if beneficio > 0:
                metricas['punto_equilibrio_a√±o'] = idx + 1
                break
        
        # Valor empresa (m√∫ltiplo de EBITDA)
        ebitda_promedio_ultimos_3 = pyl_df['EBITDA'].iloc[-3:].mean()
        multiplo_sector = 5  # Simplificado, deber√≠a venir por sector
        metricas['valor_empresa_estimado'] = round(ebitda_promedio_ultimos_3 * multiplo_sector, 0)
        
        return metricas
    
    def generar_resumen_ejecutivo(self) -> str:
        """
        Genera un resumen ejecutivo del plan financiero
        """
        pyl = self.generar_pyl()
        metricas = self.calcular_metricas_clave(pyl)
        
        resumen = f"""
        RESUMEN EJECUTIVO - {self.nombre_empresa}
        {'=' * 50}
        
        Sector: {self.sector}
        Per√≠odo de proyecci√≥n: {self.a√±o_actual} - {self.a√±o_actual + self.a√±os_proyeccion - 1}
        
        PROYECCIONES CLAVE:
        - Ventas a√±o 1: ‚Ç¨{pyl['Ventas'].iloc[0]:,.0f}
        - Ventas a√±o 5: ‚Ç¨{pyl['Ventas'].iloc[-1]:,.0f}
        - Crecimiento promedio: {metricas['crecimiento_ventas_promedio']}%
        
        RENTABILIDAD:
        - EBITDA a√±o 1: ‚Ç¨{pyl['EBITDA'].iloc[0]:,.0f} ({pyl['EBITDA %'].iloc[0]}%)
        - EBITDA a√±o 5: ‚Ç¨{pyl['EBITDA'].iloc[-1]:,.0f} ({pyl['EBITDA %'].iloc[-1]}%)
        - Margen EBITDA promedio: {metricas['margen_ebitda_promedio']}%
        
        VALORACI√ìN:
        - ROI proyectado: {metricas['roi_proyectado']}%
        - Valor estimado empresa: ‚Ç¨{metricas['valor_empresa_estimado']:,.0f}
        - Punto de equilibrio: A√±o {metricas['punto_equilibrio_a√±o']}
        """
        
        return resumen
    def calcular_working_capital(self, pyl_df: pd.DataFrame) -> pd.DataFrame:
        """
        Calcula las necesidades de Capital de Trabajo (Working Capital)
        """
        wc_data = {
            'A√±o': pyl_df['A√±o'],
            'Ventas': pyl_df['Ventas'],
            'Cuentas por Cobrar': [],
            'Inventario': [],
            'Cuentas por Pagar': [],
            'Capital de Trabajo': [],
            'Variaci√≥n WC': []
        }
        
        for i, ventas in enumerate(pyl_df['Ventas']):
            # Cuentas por cobrar (d√≠as de cobro)
            cuentas_cobrar = ventas * (self.dias_cobro / 365)
            wc_data['Cuentas por Cobrar'].append(round(cuentas_cobrar, 0))
            
            # Inventario (15% de costos para simplificar)
            inventario = ventas * self.costos_variables_pct * 0.15
            wc_data['Inventario'].append(round(inventario, 0))
            
            # Cuentas por pagar (d√≠as de pago)
            cuentas_pagar = ventas * self.costos_variables_pct * (self.dias_pago / 365)
            wc_data['Cuentas por Pagar'].append(round(cuentas_pagar, 0))
            
            # Capital de trabajo neto
            wc = cuentas_cobrar + inventario - cuentas_pagar
            wc_data['Capital de Trabajo'].append(round(wc, 0))
            
            # Variaci√≥n (necesidad de financiaci√≥n)
            if i == 0:
                variacion = wc  # Primer a√±o es el total
            else:
                variacion = wc - wc_data['Capital de Trabajo'][i-1]
            wc_data['Variaci√≥n WC'].append(round(variacion, 0))
        
        return pd.DataFrame(wc_data)
    
    def calcular_financiacion_circulante(self, wc_df: pd.DataFrame, pyl_df: pd.DataFrame) -> pd.DataFrame:
        """
        Calcula las necesidades de financiaci√≥n del circulante y p√≥lizas de cr√©dito
        """
        financiacion_data = {
            'A√±o': wc_df['A√±o'],
            'Necesidad WC': wc_df['Capital de Trabajo'],
            'L√≠mite P√≥liza': [],
            'Uso P√≥liza': [],
            'Disponible': [],
            'Coste P√≥liza': [],
            'Exceso/(D√©ficit)': []
        }
        
        for i in range(len(wc_df)):
            # L√≠mite de p√≥liza basado en ventas
            ventas = pyl_df['Ventas'].iloc[i]
            limite = self.polizas_credito['limite']
            financiacion_data['L√≠mite P√≥liza'].append(round(limite, 0))
            
            # Uso de la p√≥liza (m√°ximo entre necesidad WC y 0)
            necesidad = wc_df['Capital de Trabajo'].iloc[i]
            uso_poliza = min(max(0, necesidad), limite)
            financiacion_data['Uso P√≥liza'].append(round(uso_poliza, 0))
            
            # Disponible
            disponible = limite - uso_poliza
            financiacion_data['Disponible'].append(round(disponible, 0))
            
            # Coste financiero de la p√≥liza
            coste = uso_poliza * self.polizas_credito['tipo_interes']
            financiacion_data['Coste P√≥liza'].append(round(coste, 0))
            
            # Exceso o d√©ficit de financiaci√≥n
            exceso_deficit = limite - necesidad
            financiacion_data['Exceso/(D√©ficit)'].append(round(exceso_deficit, 0))
        
        return pd.DataFrame(financiacion_data)
    
    def calcular_free_cash_flow(self, pyl_df: pd.DataFrame, wc_df: pd.DataFrame) -> pd.DataFrame:
        """
        Calcula el Free Cash Flow (Flujo de Caja Libre)
        Usa el plan CAPEX del usuario o porcentajes por sector si no hay plan
        """
        
        # Porcentajes de CAPEX por sector (como % de ventas)
        CAPEX_POR_SECTOR = {
            'hosteler√≠a': 6.0,      # Renovaciones, equipamiento cocina
            'tecnolog√≠a': 3.0,      # Principalmente equipos inform√°ticos
            'ecommerce': 2.5,       # Tecnolog√≠a y log√≠stica ligera
            'consultor√≠a': 2.0,     # M√≠nimo, principalmente ordenadores
            'retail': 5.0,          # Renovaci√≥n tiendas, sistemas POS
            'servicios': 3.5,       # Variable, promedio general
            'automoci√≥n': 8.0,      # Equipamiento taller, herramientas
            'industrial': 10.0,     # Maquinaria pesada
            'otro': 4.0            # Promedio conservador
        }
        
        fcf_data = {
            'A√±o': pyl_df['A√±o'],
            'EBITDA': pyl_df['EBITDA'],
            'Impuestos sobre EBIT': [],
            'CAPEX': [],
            'Variaci√≥n Working Capital': wc_df['Variaci√≥n WC'],
            'Free Cash Flow': []
        }
        
        for i in range(len(pyl_df)):
            # Impuestos sobre EBIT
            impuestos_ebit = pyl_df['EBIT'].iloc[i] * self.tasa_impuesto if pyl_df['EBIT'].iloc[i] > 0 else 0
            fcf_data['Impuestos sobre EBIT'].append(round(impuestos_ebit, 0))
            
            # CAPEX: Usar plan del usuario o porcentaje por sector
            a√±o_actual = pyl_df['A√±o'].iloc[i]

            
            # Buscar si hay CAPEX planificado para este a√±o
            capex_planificado = sum([c.get('importe', 0) for c in self.plan_capex if c.get('a√±o') == a√±o_actual])
            
            
            if capex_planificado > 0:
                # Usar el CAPEX introducido por el usuario
                capex = capex_planificado
            else:
                # Usar porcentaje seg√∫n el sector
                porcentaje_capex = CAPEX_POR_SECTOR.get(self.sector, CAPEX_POR_SECTOR['Otro'])
                capex = pyl_df['Ventas'].iloc[i] * (porcentaje_capex / 100)
                print(f"DEBUG FCF - Porcentaje CAPEX: {porcentaje_capex}")
                print(f"DEBUG FCF - CAPEX calculado: {capex}")
            
            fcf_data['CAPEX'].append(round(capex, 0))
            
            # Free Cash Flow
            fcf = (pyl_df['EBITDA'].iloc[i] - 
                   impuestos_ebit - 
                   capex - 
                   wc_df['Variaci√≥n WC'].iloc[i])
            fcf_data['Free Cash Flow'].append(round(fcf, 0))
        
        return pd.DataFrame(fcf_data)
    
    def calcular_valoracion_dcf(self, fcf_df: pd.DataFrame, wacc: float = None) -> Dict:
        """
        Calcula la valoraci√≥n por DCF como los bancos de inversi√≥n
        Incluye an√°lisis de sensibilidad y m√∫ltiples m√©todos
        """
        # WACC por sector (basado en Damodaran)
        wacc_por_sector = {
            'Tecnolog√≠a': 0.12,
            'Hosteler√≠a': 0.09,
            'Ecommerce': 0.11,
            'Consultor√≠a': 0.10,
            'Retail': 0.08,
            'Servicios': 0.09,
            'Industrial': 0.08,
            'Automoci√≥n': 0.09,
            'Otro': 0.10
        }
        
        # Usar WACC espec√≠fico del sector si no se proporciona
        if wacc is None:
            wacc = wacc_por_sector.get(self.sector, 0.10)
        
        # 1. M√âTODO DCF CL√ÅSICO
        # Calcular valor presente de los flujos (a√±os 1-5)
        valores_presentes = []
        for i in range(len(fcf_df)):
            vp = fcf_df['Free Cash Flow'].iloc[i] / ((1 + wacc) ** (i + 1))
            valores_presentes.append(vp)
        
        # Valor terminal - M√©todo de crecimiento perpetuo (Gordon Growth)
        fcf_ultimo = fcf_df['Free Cash Flow'].iloc[-1]
        g = 0.025  # 2.5% crecimiento perpetuo (conservador)
        
        # Normalizar FCF del √∫ltimo a√±o si es necesario
        fcf_normalizado = fcf_ultimo
        if fcf_ultimo < fcf_df['EBITDA'].iloc[-1] * 0.3:  # Si FCF < 30% EBITDA
            # Usar promedio de los √∫ltimos 3 a√±os
            fcf_normalizado = fcf_df['Free Cash Flow'].iloc[-3:].mean()
        
        valor_terminal_gg = fcf_normalizado * (1 + g) / (wacc - g)
        
        # Valor terminal - M√©todo de m√∫ltiplo de salida
        ebitda_ultimo = fcf_df['EBITDA'].iloc[-1]
        multiplos_salida = {
            'Tecnolog√≠a': 15.0,
            'Hosteler√≠a': 8.0,
            'Ecommerce': 12.0,
            'Consultor√≠a': 10.0,
            'Retail': 7.0,
            'Servicios': 9.0,
            'Industrial': 8.0,
            'Automoci√≥n': 7.0,
            'Otro': 9.0
        }
        multiplo_exit = multiplos_salida.get(self.sector, 9.0)
        valor_terminal_multiplo = ebitda_ultimo * multiplo_exit
        
        # Promedio ponderado de ambos m√©todos (60% Gordon, 40% M√∫ltiplo)
        valor_terminal = valor_terminal_gg * 0.6 + valor_terminal_multiplo * 0.4
        
        # Valor presente del valor terminal
        vp_valor_terminal = valor_terminal / ((1 + wacc) ** len(fcf_df))
        
        # Enterprise Value
        enterprise_value = sum(valores_presentes) + vp_valor_terminal
        
        # 2. AJUSTES AL ENTERPRISE VALUE
        # Agregar: Caja y equivalentes (estimado como 10% de ventas √∫ltimo a√±o)
        caja_estimada = fcf_df['Free Cash Flow'].iloc[:2].mean() * 0.5  # Conservador
        
        # Bridge to Equity Value
        # Calcular deuda total actual
        deuda_total = (self.prestamos_lp['principal'] + 
                        self.hipotecas['principal'] + 
                        self.polizas_credito['dispuesto'])

        equity_value = enterprise_value + caja_estimada - deuda_total
        
        # 3. AN√ÅLISIS DE M√öLTIPLOS COMPARABLES
        # M√∫ltiplos actuales de mercado por sector
        ev_ventas_multiples = {
            'Tecnolog√≠a': 4.5,
            'Hosteler√≠a': 1.2,
            'Ecommerce': 2.0,
            'Consultor√≠a': 2.5,
            'Retail': 0.8,
            'Servicios': 1.5,
            'Industrial': 1.0,
            'Automoci√≥n': 0.7,
            'Otro': 1.5
        }
        
        # Estimaci√≥n m√°s conservadora de ventas del a√±o 5
        crecimiento_anual = self._calcular_crecimiento_historico()
        if crecimiento_anual > 1:
            crecimiento_anual = crecimiento_anual / 100
        # Aplicar crecimiento compuesto m√°s realista
        ventas_ultimo = self.ventas_historicas[-1] * ((1 + crecimiento_anual) ** 5)
        ev_por_multiplo_ventas = ventas_ultimo * ev_ventas_multiples.get(self.sector, 1.5)
        
        # 4. VALORACI√ìN FINAL (Promedio ponderado)
        # 70% DCF, 30% M√∫ltiplos (est√°ndar en banca de inversi√≥n)
        valoracion_final = enterprise_value * 0.7 + ev_por_multiplo_ventas * 0.3
        
        # 5. AN√ÅLISIS DE SENSIBILIDAD
        # Escenarios de WACC
        wacc_bear = wacc + 0.02  # +2%
        wacc_bull = wacc - 0.01  # -1%
        
        # Recalcular para escenarios
        ev_bear = sum([fcf_df['Free Cash Flow'].iloc[i] / ((1 + wacc_bear) ** (i + 1)) 
                      for i in range(len(fcf_df))])
        ev_bear += (valor_terminal / ((1 + wacc_bear) ** len(fcf_df)))
        
        ev_bull = sum([fcf_df['Free Cash Flow'].iloc[i] / ((1 + wacc_bull) ** (i + 1)) 
                      for i in range(len(fcf_df))])
        ev_bull += (valor_terminal / ((1 + wacc_bull) ** len(fcf_df)))
        
        # Retornar diccionario completo estilo pitch deck
        return {
            # Valoraci√≥n principal
            'valor_empresa': round(valoracion_final, 0),
            'valor_equity': round(equity_value, 0),
            
            # Componentes de valor
            'valor_presente_fcf': round(sum(valores_presentes), 0),
            'valor_terminal': round(valor_terminal, 0),
            'valor_terminal_pct': round((vp_valor_terminal / enterprise_value) * 100, 1),
            
            # M√∫ltiplos impl√≠citos
            'ev_ebitda_actual': round(enterprise_value / fcf_df['EBITDA'].iloc[0], 1),
            'ev_ebitda_salida': round(enterprise_value / ebitda_ultimo, 1),
            'ev_ventas': round(enterprise_value / ventas_ultimo, 1),
            
            # Par√°metros clave
            'wacc_utilizado': round(wacc * 100, 1),
            'tasa_crecimiento_terminal': g * 100,
            'multiplo_salida_usado': multiplo_exit,
            
            # An√°lisis de sensibilidad
            'valoracion_escenario_bajo': round(ev_bear, 0),
            'valoracion_escenario_alto': round(ev_bull, 0),
            'rango_valoracion': f"‚Ç¨{ev_bear:,.0f} - ‚Ç¨{ev_bull:,.0f}",
            
            # M√©tricas de retorno
            'tir_esperada': round(((max(0.01, equity_value) / max(1, self.ventas_historicas[-1] * 0.2)) ** (1/5) - 1) * 100, 1) if equity_value > 0 else 0,
            'money_multiple': round(equity_value / (self.ventas_historicas[-1] * 0.2), 1)
        }
    
    def generar_analisis_ia(self, pyl_df: pd.DataFrame, valoracion: Dict, financiacion_df: pd.DataFrame) -> Dict:
        """
        Genera un an√°lisis inteligente con recomendaciones tipo consultor√≠a
        """
        # M√©tricas clave para el an√°lisis
        crecimiento_ventas = ((pyl_df['Ventas'].iloc[-1] / pyl_df['Ventas'].iloc[0]) ** (1/5) - 1) * 100
        margen_ebitda_inicial = pyl_df['EBITDA %'].iloc[0]
        margen_ebitda_final = pyl_df['EBITDA %'].iloc[-1]
        roi = valoracion.get('tir_esperada', 0)
        multiplo_ebitda = valoracion.get('ev_ebitda_salida', 0)
        deficit_max = financiacion_df['Exceso/(D√©ficit)'].min() if len(financiacion_df) > 0 else 0
        
        # AGREGAR AQU√ç - Datos macroecon√≥micos para el an√°lisis
        contexto_macro = {
            'pib_medio': 1.95,  # Media 2024-2026
            'inflacion_media': 2.53,  # Media 2024-2026
            'euribor_medio': 2.67,  # Media 2024-2026
            'desempleo_medio': 11.7,  # Media 2024-2026
        }
        
        # Crecimiento esperado por sector (basado en informes oficiales)
        crecimiento_sectorial = {
            'Tecnolog√≠a': 15.0,
            'Hosteler√≠a': 6.0,
            'Automoci√≥n': 4.0,
            'Ecommerce': 9.0,
            'Consultor√≠a': 8.0,
            'Retail': 3.5,
            'Servicios': 5.0,
            'Industrial': 4.0,
            'Otro': 3.0
        }
        
        crecimiento_esperado_sector = crecimiento_sectorial.get(self.sector, 3.0)
        
        # An√°lisis por componentes
        analisis = {
            'resumen_ejecutivo': '',
            'fortalezas': [],
            'riesgos': [],
            'recomendaciones': [],
            'rating': '',
            'viabilidad': ''
        }
        
        # Evaluaci√≥n de crecimiento con contexto sectorial
        diferencia_sector = crecimiento_ventas - crecimiento_esperado_sector
        
        if diferencia_sector > 5:
            analisis['fortalezas'].append(f"Crecimiento del {crecimiento_ventas:.1f}% anual, superando ampliamente la media del sector ({crecimiento_esperado_sector:.1f}%)")
        elif diferencia_sector > 0:
            analisis['fortalezas'].append(f"Crecimiento del {crecimiento_ventas:.1f}% anual, por encima de la media sectorial")
        else:
            analisis['riesgos'].append(f"Crecimiento del {crecimiento_ventas:.1f}% anual, por debajo del sector ({crecimiento_esperado_sector:.1f}%)")
        
        # An√°lisis del contexto macroecon√≥mico
        if crecimiento_ventas > contexto_macro['pib_medio'] * 2:
            analisis['fortalezas'].append(f"Crecimiento muy superior al PIB esperado ({contexto_macro['pib_medio']:.1f}%)")
        
        # Evaluaci√≥n del impacto de tipos de inter√©s
        if contexto_macro['euribor_medio'] > 3 and margen_ebitda_final < 15:
            analisis['riesgos'].append(f"M√°rgenes ajustados en entorno de tipos altos (Euribor medio {contexto_macro['euribor_medio']:.1f}%)")
        # Evaluaci√≥n de m√°rgenes
        mejora_margen = margen_ebitda_final - margen_ebitda_inicial
        if mejora_margen > 5:
            analisis['fortalezas'].append(f"Excelente mejora de m√°rgenes (+{mejora_margen:.1f}pp)")
        elif mejora_margen > 0:
            analisis['fortalezas'].append(f"Mejora progresiva de m√°rgenes (+{mejora_margen:.1f}pp)")
        else:
            analisis['riesgos'].append("M√°rgenes estancados o decrecientes")
        
        # Evaluaci√≥n financiera
        if deficit_max < 0:
            analisis['riesgos'].append(f"D√©ficit de financiaci√≥n de ‚Ç¨{abs(deficit_max):,.0f}")
            analisis['recomendaciones'].append("Negociar ampliaci√≥n de l√≠neas de cr√©dito antes del inicio del proyecto")
        
        if roi > 25:
            analisis['fortalezas'].append(f"ROI excepcional del {roi:.1f}%")
        elif roi > 15:
            analisis['fortalezas'].append(f"ROI atractivo del {roi:.1f}%")
        else:
            analisis['riesgos'].append(f"ROI moderado del {roi:.1f}%")
        
        # Recomendaciones por sector
        recomendaciones_sector = {
            'Tecnolog√≠a': [
                "Invertir en I+D para mantener ventaja competitiva",
                "Considerar modelo SaaS para ingresos recurrentes",
                "Explorar mercados internacionales"
            ],
            'Hosteler√≠a': [
                "Implementar sistema de gesti√≥n de inventarios para reducir mermas",
                "Desarrollar programa de fidelizaci√≥n",
                "Optimizar horarios seg√∫n an√°lisis de demanda"
            ],
            'Automoci√≥n': [
                "Diversificar proveedores para reducir riesgo",
                "Negociar plazos de pago m√°s largos",
                "Considerar factoring para mejorar liquidez"
            ],
            'Ecommerce': [
                "Invertir en marketing digital y SEO",
                "Optimizar log√≠stica de √∫ltima milla",
                "Desarrollar marketplace o dropshipping"
            ]
        }
        
        # Agregar recomendaciones sectoriales
        if self.sector in recomendaciones_sector:
            analisis['recomendaciones'].extend(recomendaciones_sector[self.sector])
        
        # Recomendaciones financieras generales
        if margen_ebitda_final < 15:
            analisis['recomendaciones'].append("Revisar estructura de costos para mejorar m√°rgenes")
        
        if self.dias_cobro > 60:
            analisis['recomendaciones'].append("Implementar pol√≠ticas de cobro m√°s agresivas")

        # Recomendaciones basadas en contexto macroecon√≥mico
        if contexto_macro['inflacion_media'] > 2.5:
            analisis['recomendaciones'].append("Implementar cl√°usulas de revisi√≥n de precios en contratos para protegerse de la inflaci√≥n")
        
        if contexto_macro['euribor_medio'] > 2.5 and deficit_max < 0:
            analisis['recomendaciones'].append("Considerar financiaci√≥n alternativa (crowdlending, factoring) ante tipos elevados")
        
        if contexto_macro['desempleo_medio'] > 10 and self.sector in ['Retail', 'Hosteler√≠a']:
            analisis['recomendaciones'].append("Aprovechar disponibilidad de talento y posibles ayudas a la contrataci√≥n")
        
        # Recomendaciones espec√≠ficas por comparaci√≥n sectorial
        if diferencia_sector < -2:
            analisis['recomendaciones'].append(f"Analizar estrategias de los l√≠deres del sector para acelerar crecimiento")
            analisis['recomendaciones'].append("Considerar alianzas estrat√©gicas o adquisiciones para ganar cuota de mercado")
        
        # Determinar rating
        puntuacion = 0
        puntuacion += 2 if crecimiento_ventas > 15 else 1 if crecimiento_ventas > 5 else 0
        puntuacion += 2 if mejora_margen > 5 else 1 if mejora_margen > 0 else 0
        puntuacion += 2 if roi > 20 else 1 if roi > 10 else 0
        puntuacion += 1 if deficit_max >= 0 else 0
        
        if puntuacion >= 6:
            analisis['rating'] = '‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê Excelente'
            analisis['viabilidad'] = 'ALTA'
        elif puntuacion >= 4:
            analisis['rating'] = '‚≠ê‚≠ê‚≠ê‚≠ê Bueno'
            analisis['viabilidad'] = 'MEDIA-ALTA'
        elif puntuacion >= 2:
            analisis['rating'] = '‚≠ê‚≠ê‚≠ê Regular'
            analisis['viabilidad'] = 'MEDIA'
        else:
            analisis['rating'] = '‚≠ê‚≠ê Mejorable'
            analisis['viabilidad'] = 'BAJA'
        
        # Generar resumen ejecutivo con contexto macro
        comparacion_sector = "por encima" if diferencia_sector > 0 else "por debajo"
        puntos_diferencia = abs(diferencia_sector)
        
        analisis['resumen_ejecutivo'] = f"""
        La empresa {self.nombre_empresa} del sector {self.sector} presenta un plan de negocio con 
        crecimiento proyectado del {crecimiento_ventas:.1f}% anual ({puntos_diferencia:.1f}pp {comparacion_sector} 
        de la media sectorial del {crecimiento_esperado_sector:.1f}%), alcanzando ventas de ‚Ç¨{pyl_df['Ventas'].iloc[-1]:,.0f} 
        en el a√±o 5. 
        
        En un contexto macroecon√≥mico de crecimiento moderado (PIB {contexto_macro['pib_medio']:.1f}%), 
        inflaci√≥n controlada ({contexto_macro['inflacion_media']:.1f}%) y tipos de inter√©s en descenso 
        (Euribor medio {contexto_macro['euribor_medio']:.1f}%), la empresa muestra una evoluci√≥n del EBITDA 
        desde {margen_ebitda_inicial:.1f}% hasta {margen_ebitda_final:.1f}%.
        
        La valoraci√≥n estimada es de ‚Ç¨{valoracion['valor_empresa']:,.0f} (m√∫ltiplo {multiplo_ebitda:.1f}x EBITDA), 
        con un ROI esperado del {roi:.1f}%. La viabilidad del proyecto se considera {analisis['viabilidad']}.
        """
        return analisis
     
    def generar_resumen_ejecutivo(self):
        """
        Genera un resumen ejecutivo en texto para el business plan
        """
        # Calcular m√©tricas si no existen
        # Usar el P&L ya generado si existe, sino generar uno nuevo
        if self.pyl is not None:
            pyl = self.pyl
        else:
            self.generar_pyl(5)  # Generar con 5 a√±os
            pyl = self.pyl
        metricas = self.calcular_metricas_clave(pyl)
        
        resumen = f"""
RESUMEN EJECUTIVO - {self.nombre_empresa}
{'=' * 60}

INFORMACI√ìN GENERAL
------------------
Empresa: {self.nombre_empresa}
Sector: {self.sector}
Fecha de an√°lisis: {datetime.now().strftime('%d/%m/%Y')}

SITUACI√ìN ACTUAL
----------------
Ventas actuales: ‚Ç¨{self.ventas_historicas[-1]:,.0f}
Crecimiento hist√≥rico: {self._calcular_crecimiento_historico():.1f}% anual
Estructura de costos:
  - Costos variables: {self.costos_variables_pct*100:.0f}% de ventas
  - Gastos de personal: ‚Ç¨{self.gastos_personal:,.0f}
  - Gastos generales: ‚Ç¨{self.gastos_generales:,.0f}
  - Gastos de marketing: ‚Ç¨{self.gastos_marketing:,.0f}

PROYECCIONES A 5 A√ëOS
---------------------
Ventas a√±o 5: ‚Ç¨{pyl['Ventas'].iloc[-1]:,.0f}
Crecimiento promedio anual: {metricas['crecimiento_ventas_promedio']:.1f}%

EBITDA a√±o 5: ‚Ç¨{pyl['EBITDA'].iloc[-1]:,.0f}
Margen EBITDA a√±o 5: {pyl['EBITDA %'].iloc[-1]:.1f}%

Beneficio neto a√±o 5: ‚Ç¨{pyl['Beneficio Neto'].iloc[-1]:,.0f}
Margen neto a√±o 5: {pyl['Beneficio Neto %'].iloc[-1]:.1f}%

INDICADORES CLAVE
-----------------
ROI proyectado: {metricas['roi_proyectado']:.1f}%
Periodo de recuperaci√≥n: {metricas.get('payback_period', 'N/A')}
TIR del proyecto: {metricas.get('tir_proyecto', 'Por calcular')}

CONCLUSIONES
------------
El proyecto muestra una evoluci√≥n {self._evaluar_evolucion(metricas)} con:
- Crecimiento sostenido de ventas
- Mejora progresiva de m√°rgenes
- Generaci√≥n positiva de caja
- Retorno atractivo sobre la inversi√≥n

RECOMENDACIONES
---------------
1. Mantener control estricto de costos variables
2. Optimizar gastos de personal mediante productividad
3. Incrementar inversi√≥n en marketing para acelerar crecimiento
4. Considerar financiaci√≥n para capital de trabajo inicial
5. Monitorear m√©tricas mensualmente vs. proyecciones

{'=' * 60}
Documento generado por Business Plan IA
"""
        return resumen

    def _calcular_crecimiento_historico(self):
        """Calcula el crecimiento hist√≥rico promedio"""
        ventas = self.ventas_historicas
        if len(ventas) < 2:
            return 0
        
        crecimiento_total = (ventas[-1] / ventas[0]) ** (1 / (len(ventas) - 1)) - 1
        return crecimiento_total * 100

    def _evaluar_evolucion(self, metricas):
        """Eval√∫a si la evoluci√≥n es positiva, moderada o necesita mejoras"""
        roi = metricas['roi_proyectado']
        if roi > 25:
            return "muy positiva"
        elif roi > 15:
            return "positiva"
        elif roi > 10:
            return "moderada"
        else:
            return "que requiere optimizaci√≥n"   
        
    def realizar_valoracion_bancainversion(self) -> Dict:
        """
        Realiza valoraci√≥n profesional con metodolog√≠a de banca de inversi√≥n
        
        Returns:
            Dict con valoraci√≥n completa incluyendo DCF, m√∫ltiplos y transacciones
        """
        try:
            # Asegurarse de que hay proyecciones generadas
            if self.pyl is None or self.cash_flow is None:
                raise ValueError("Debe generar proyecciones antes de valorar")
            
            # Realizar valoraci√≥n completa
    # valoracion = realizar_valoracion_profesional(self)
            
            # A√±adir informaci√≥n adicional
            valoracion['empresa'] = self.nombre
            valoracion['sector'] = self.sector
            valoracion['fecha_valoracion'] = datetime.now().strftime('%Y-%m-%d')
            
            return valoracion
            
        except Exception as e:
            import traceback; print(f"Error en valoraci√≥n profesional: {e}"); traceback.print_exc()
            return {
                'error': str(e),
                'valoracion_disponible': False
            }
    
# Funci√≥n de prueba
if __name__ == "__main__":
    
    # Datos de ejemplo para testing
    datos_prueba = {
        'nombre': 'PYME Test SL',
        'sector': 'Tecnolog√≠a',
        'ventas_historicas': [500000, 650000, 780000],
        'costos_variables_pct': 0.6,
        'gastos_personal': 150000,
        'gastos_generales': 50000,
        'gastos_marketing': 30000,
        'otros_gastos': 20000
    }
    
    # Crear modelo y generar P&L
    modelo = ModeloFinanciero(datos_prueba)
    pyl = modelo.generar_pyl()
    
    print("\nP&L PROYECTADO:")
    print(pyl.to_string(index=False))
    
    print("\n" + modelo.generar_resumen_ejecutivo())